[
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Définition de fonctions en R",
    "section": "",
    "text": "En R, on définit une fonction de cette manière :\n\n\n\n\n\n\nLa fonction super_calcul a plusieurs paramètres : a, b et multiplication. On donne à ces paramètres des valeurs qu’on appelle arguments. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.\nOn appelle une fonction de cette manière :\n\n\n\n\n\n\nLes arguments s’évaluent dans l’ordre qu’ils sont stipulés lors de la définition, on peut donc écrire de manière équivalente :\n\n\n\n\n\n\nOn remarque que dans la définition de fonction, on avait écrit multiplication = TRUE. Cela correspond à un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera TRUE comme on peut le vérifier ci-dessous.\n\n\n\n\n\n\nSi la valeur que l’on veut utilise est différente de l’argument par défaut, on est obligé de la saisir.\n\n\n\n\n\n\nOn peut, lors de l’appel, nommer explicitement certains arguments et pas d’autres. Si on procède ainsi, les arguments non-nommés sont attribués de gauche à droite, parmi ceux qui ne sont pas nommés. Ainsi, tous les appels ci-dessous sont équivalents.\n\n\n\n\n\n\nSi un paramètre n’a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l’appel de fonction. C’est pourquoi le code ci-dessous renvoie une erreur.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa dernière remarque n’est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l’aide de if (missing(argument)) {}. Ceci est toutefois, en général, considéré comme une mauvaise pratique.\n\n\nOn vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que if () else {}). Une manière explicite de renvoyer une valeur de retour est d’invoquer return(). Appeler return() met fin à l’exécution de la fonction. Tout ce qui vient après n’est jamais rappelé.\n\n\n\n\n\n\ncalcula() renvoie 2L, tandis que calculb() renvoie 3L. On aurait pu également constater que, dans calcula, si on remplace 3L par stop(), le stop n’empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#définition-de-fonction",
    "href": "fonctions.html#définition-de-fonction",
    "title": "Définition de fonctions en R",
    "section": "",
    "text": "En R, on définit une fonction de cette manière :\n\n\n\n\n\n\nLa fonction super_calcul a plusieurs paramètres : a, b et multiplication. On donne à ces paramètres des valeurs qu’on appelle arguments. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.\nOn appelle une fonction de cette manière :\n\n\n\n\n\n\nLes arguments s’évaluent dans l’ordre qu’ils sont stipulés lors de la définition, on peut donc écrire de manière équivalente :\n\n\n\n\n\n\nOn remarque que dans la définition de fonction, on avait écrit multiplication = TRUE. Cela correspond à un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera TRUE comme on peut le vérifier ci-dessous.\n\n\n\n\n\n\nSi la valeur que l’on veut utilise est différente de l’argument par défaut, on est obligé de la saisir.\n\n\n\n\n\n\nOn peut, lors de l’appel, nommer explicitement certains arguments et pas d’autres. Si on procède ainsi, les arguments non-nommés sont attribués de gauche à droite, parmi ceux qui ne sont pas nommés. Ainsi, tous les appels ci-dessous sont équivalents.\n\n\n\n\n\n\nSi un paramètre n’a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l’appel de fonction. C’est pourquoi le code ci-dessous renvoie une erreur.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa dernière remarque n’est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l’aide de if (missing(argument)) {}. Ceci est toutefois, en général, considéré comme une mauvaise pratique.\n\n\nOn vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que if () else {}). Une manière explicite de renvoyer une valeur de retour est d’invoquer return(). Appeler return() met fin à l’exécution de la fonction. Tout ce qui vient après n’est jamais rappelé.\n\n\n\n\n\n\ncalcula() renvoie 2L, tandis que calculb() renvoie 3L. On aurait pu également constater que, dans calcula, si on remplace 3L par stop(), le stop n’empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#dots",
    "href": "fonctions.html#dots",
    "title": "Définition de fonctions en R",
    "section": "Dots",
    "text": "Dots\nLorsque le nombre de paramètres d’une fonction peut être variable, on peut utiliser les ... qu’on appelle “dots”. list(...) permet de retrouver ces arguments sous forme de liste dans le corps de la fonction.\n\n\n\n\n\n\nDans le code précédent, on a pu définir une fonction de somme sans figer à l’avance le nombre de termes de la somme.\n\n\n\n\n\n\nNote\n\n\n\nOn a utilisé dans super_somme une fonction particulière, Reduce, qui est typique des langages fonctionnels. L’idée est ici que l’on calcule 2 + 3 + 7 + 1. On verra plus en détail ce type d’opérations dans la partie dédiée au paradigme fonctionnel.\nDans le cas présent, sum existe déjà et peut déjà s’appliquer à un vecteur. On n’a écrit super_somme qu’à fin d’illustration.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#appeler-une-fonction-dots-sur-une-liste",
    "href": "fonctions.html#appeler-une-fonction-dots-sur-une-liste",
    "title": "Définition de fonctions en R",
    "section": "Appeler une fonction dots sur une liste",
    "text": "Appeler une fonction dots sur une liste\nImaginons que l’on veuille appeler une fonction ... sur une liste. On souhaite que chaque élément de la liste devienne un argument. On peut par exemple faire, sur notre fonction super_somme.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa fonction do.call est en réalité plus générale que cela. Elle permet également d’utiliser des arguments nommés, comme on peut le voir dans l’exemple suivant :",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#fonctions-récursives",
    "href": "fonctions.html#fonctions-récursives",
    "title": "Définition de fonctions en R",
    "section": "Fonctions récursives",
    "text": "Fonctions récursives\nLes fonctions en R peuvent tout-à-fait être récursives. Par exemple, même si factorial() existe déjà dans R, on pourrait très bien la redéfinir via :\n\n\n\n\n\n\nR permet également une petite astuce pour éviter d’avoir à utiliser le nom d’une fonction dans son propre corps (cela permet de pouvoir renommer la fonction à un seul endroit). Le code précédent est équivalent à :\n\n\n\n\n\n\n\n\n\n\n\n\nRemarque optionnelle\n\n\n\nDepuis R 4.4.0 sortie fin avril 2024 (pas avant !), on peut utiliser la fonction Tailcall pour faire des récursivités terminales ; qui sont moins pratiques à lire mais plus efficaces. L’interface n’est pas encore figée mais cela ressemble aujourd’hui à :",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#exercices",
    "href": "fonctions.html#exercices",
    "title": "Définition de fonctions en R",
    "section": "Exercices",
    "text": "Exercices\nQuestion 1\nEcrire une fonction super_produit &lt;- function(...) qui calcule le produit de tous les arguments sous les dots, et l’utiliser pour écrire une nouvelle version de la fonction fact.\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nsuper_produit &lt;- function(...) {\n  dots &lt;- list(...)\n  Reduce(`*`, dots)\n}\nfact &lt;- function(n) {\n  do.call(super_produit, as.list(1L:n))\n}\nfact(10)\n\n[1] 3628800\n\n\n\n\n\nQuestion 2\nÉcrire une fonction dots usine_a_gaz qui renvoie :\n\nNULL s’il n’y a aucun argument.\nLe nombre d’arguments s’il y en a deux ou plus.\n\"bonjour\" si on lui soumet en unique argument un vecteur de type character (is.character permet de faire le test).\nLa somme du vecteur si on lui soumet en unique argument un vecteur numérique au sens de is.numeric.\n\"échec\" dans tous les autres cas.\n\nOn pourra éventuellement s’aider des petites astuces, dont ...length(), lisibles dans la page d’aide des .... Celle-ci est accessible en tapant help(dots).\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nusine_a_gaz &lt;- function(...) {\n  longueur &lt;- ...length()\n  if (longueur == 0) NULL\n  else if (longueur &gt;= 2L) longueur\n  else if (is.character(..1)) \"bonjour\"\n  else if (is.numeric(..1)) sum(..1)\n  else \"échec\"\n}\nusine_a_gaz()\n\nNULL\n\nusine_a_gaz(1,3)\n\n[1] 2\n\nusine_a_gaz(c(\"a\",\"b\"))\n\n[1] \"bonjour\"\n\nusine_a_gaz(c(1, 2))\n\n[1] 3\n\nusine_a_gaz(c(1L, 2L))\n\n[1] 3\n\nusine_a_gaz(list())\n\n[1] \"échec\"\n\n\nOn peut également utiliser des return(), auquel cas les else deviennent inutiles puisque return fait directement retourner la fonction.\n\nusine_a_gaz &lt;- function(...) {\n  longueur &lt;- ...length()\n  if (longueur == 0) return(NULL)\n  if (longueur &gt;= 2L) return(longueur)\n  if (is.character(..1)) return(\"bonjour\")\n  if (is.numeric(..1)) return(sum(..1))\n  \"échec\"\n}\nusine_a_gaz()\n\nNULL\n\nusine_a_gaz(1,3)\n\n[1] 2\n\nusine_a_gaz(c(\"a\",\"b\"))\n\n[1] \"bonjour\"\n\nusine_a_gaz(c(1, 2))\n\n[1] 3\n\nusine_a_gaz(c(1L, 2L))\n\n[1] 3\n\nusine_a_gaz(list())\n\n[1] \"échec\"\n\n\n\n\n\nQuestion 3\nRéécrire la fonction super_somme en utilisant une syntaxe récursive. On pourra, par exemple, s’aider de la fonction head, qui permet de retourner une sous-liste contenant les n premiers éléments d’une liste.\n\n\n\n\n\n\n\n\n\n\n\n\nAide (optionnel mais à ne pas consulter avant 5 minutes de brainstorming !)\n\n\n\n\n\n\nsuper_somme &lt;- function(...) {\n  dots &lt;- list(...)\n  longueur &lt;- length(dots)\n  if (longueur == 0L) 0\n  else dots[[longueur]] + do.call(\n    # Rajouter quelque chose dans le do.call qui rappelle super_somme sur les longueur - 1L premiers éléments \n  )\n}\nsuper_somme(2, 3, 7, 1)\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nsuper_somme &lt;- function(...) {\n  dots &lt;- list(...)\n  longueur &lt;- length(dots)\n  if (longueur == 0L) 0\n  else dots[[longueur]] + do.call(super_somme, head(dots, longueur - 1L))\n}\nsuper_somme(2, 3, 7, 1)\n\n[1] 13\n\n\n\n\n\n\n\n\nRemarques\n\n\n\n\nLa récursivité est ici très bourrine ! On le fait juste pour l’exercice.\nQuelques petites astuces permettent, si besoin, d’éviter de convertir tous les arguments d’une fonction dots en liste. On dispose par exemple de ...length() en tant que substitut pour length(list(...)).\nOn peut éventuellement utiliser Recall en tant que substitut pour super_somme dans le do.call.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html",
    "href": "fonctions_ordre_superieur_1.html",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "",
    "text": "En informatique, la notion de fonction d’ordre supérieur désigne une fonction avec au moins l’une des propriétés suivantes :\n\nElle a pour argument une ou des fonctions.\nElles retournent a minima une fonction.\n\nLes fonctions d’ordre supérieur sont un élément central permettant l’expressivité des langages fonctionnels.\nDans cette première partie sur les fonctions d’ordre supérieur, nous abordons la thématique des fonctions avec ayant des arguments fonctionnels.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#fonctions-dordre-supérieur",
    "href": "fonctions_ordre_superieur_1.html#fonctions-dordre-supérieur",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "",
    "text": "En informatique, la notion de fonction d’ordre supérieur désigne une fonction avec au moins l’une des propriétés suivantes :\n\nElle a pour argument une ou des fonctions.\nElles retournent a minima une fonction.\n\nLes fonctions d’ordre supérieur sont un élément central permettant l’expressivité des langages fonctionnels.\nDans cette première partie sur les fonctions d’ordre supérieur, nous abordons la thématique des fonctions avec ayant des arguments fonctionnels.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#manipuler-des-fonctions-avec-des-fonctions",
    "href": "fonctions_ordre_superieur_1.html#manipuler-des-fonctions-avec-des-fonctions",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "Manipuler des fonctions avec des fonctions",
    "text": "Manipuler des fonctions avec des fonctions\nOn a déjà vu dans le point précédent deux fonctions qui s’appliquent sur des fonctions. do.call nous a permis d’appliquer une fonction de type function(...) sur une liste, tandis que Reduce nous a permis d’écrire 2 + 3 + 7 + 1 de manière un peu plus jolie qu’à la main.\nOn a vu dans l’introduction, également, que R est un langage principalement fonctionnel. R offre un certain nombre de fonctions permettant d’appliquer des fonctions de différentes manières. Nous verrons ici lapply, vapply, Map, replicate, apply, do.call, Reduce.\n\n\n\n\n\n\n\nRemarque optionnelle\n\n\n\nUn package du tidyverse, purrr, donne accès à des fonctions similaires à toutes celles décrites dans cette partie. Ce lien donne des équivalents purrristes des fonctions d’ordre supérieur abordées ici.\nL’usage est selon les gouts et les couleurs. Utiliser les fonctions de base est suffisant et permet de se débarasser d’une dépendance, mais purrr est plus cohérent avec le reste de l’écosystème tidyverse. Par exemple, il permet de passer facilement au package de parallélisation furrr.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#lapply-appliquer-une-fonction-à-chaque-élément-dune-liste-ou-dun-vecteur",
    "href": "fonctions_ordre_superieur_1.html#lapply-appliquer-une-fonction-à-chaque-élément-dune-liste-ou-dun-vecteur",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "lapply : appliquer une fonction à chaque élément d’une liste ou d’un vecteur",
    "text": "lapply : appliquer une fonction à chaque élément d’une liste ou d’un vecteur\n\n\n\n\n\n\nLa fonction function(x) c(x, x, x) demande à répéter trois fois un élément. Cette fonction est appliquée terme à terme à chaque élement de la liste.\n\nc(\"a\", \"b\") donne c(\"a\", \"b\", \"a\", \"b\", \"a\", \"b\")\nc(\"c\", \"d\", \"e\") donne c(\"c\", \"d\", \"e\", \"c\", \"d\", \"e\", \"c\", \"d\", \"e\")\nc(\"f\", \"g\") donne c(\"f\", \"g\", \"f\", \"g\", \"f\", \"g\")\n\n\n\n\n\n\n\nLe calcul ci-dessus montre qu’on peut utiliser lapply à l’intérieur d’une autre fonction.\n\n\n\n\n\n\nOn s’est d’ailleurs permis ici de remplacer function(x) c(x, x, x) par une fonction nommée qui s’appelle repeter. Ce petit changement illustre un aspect implicite des deux précédentes syntaxes utilisées : on utilisait function(x) c(x, x, x) en lieu et place d’un nom de fonction à l’intérieur du lapply ! On appelle de telles fonctions, dépourvues de noms, des fonctions anonymes. Si une fonction n’a pour vocation que d’être utilisée une seule fois, cela peut rendre la syntaxe plus claire et plus élégante qu’une fonction nommée.\n\n\n\n\n\n\nDans ce dernier calcul, on remarque que l’on peut appliquer lapply sur un vecteur.\nToutefois, dans les 4 calculs, le résultat de lapply est une liste. lapply retourne une liste même quand on lui soumet un vecteur.\n\n\n\n\n\n\nNote\n\n\n\nDans les versions de R récentes, on peut utiliser la notation compacte \\(x) c(x, x, x) à la place de function(x) c(x, x, x) pour désigner une fonction.\nÀ l’intérieur de l’écosystème tidyverse, on peut également utiliser la notation ~c(.x, .x, .x).",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#map-appliquer-une-fonction-multi-paramètres-termes-à-termes",
    "href": "fonctions_ordre_superieur_1.html#map-appliquer-une-fonction-multi-paramètres-termes-à-termes",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "Map : appliquer une fonction multi-paramètres termes à termes",
    "text": "Map : appliquer une fonction multi-paramètres termes à termes\nOn a vu avec lapply comment appliquer une fonction sur chaque termes d’une liste ou d’un vecteur et retourner une liste. Cependant, parfois, un seul argument ne suffit pas, et l’on a envie d’appliquer une fonction terme à terme sur plusieurs listes ou vecteurs. La fonction Map remplit ce besoin.\n\n\n\n\n\n\nOn voit ici que la fonction Map permet d’appliquer termet à terme la fonction paste sur plusieurs vecteurs character.\n\n\n\n\n\n\nL’argument MoreArgs de Map permet de rajouter une liste d’arguments complémentaires, qui restent fixes entre tous les appels.\n\n\n\n\n\n\nOn aurait aussi tout aussi pu utiliser une fonction anonyme pour spécifier des arguments complémentaires. C’est au choix !\n\n\n\n\n\n\nOn vérifie ci-dessus que la fonction Map permet d’utiliser plus que deux arguments.\n\n\n\n\n\n\nLa fonction Map peut tout-à-fait utiliser des listes. Ici, elle renvoie donc une liste appliquant la fonction + terme à terme :\n\nc(1L, 2L, 3L) + c(10L, 11L, 12L) pour le premier terme.\nc(4L, 5L, 6L, 7L) + c(13L, 14L, 15L, 16L) pour le deuxième terme.\nc(8L, 9L) + c(17L, 18L) pour le troisième terme.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#replicate-une-variante-commode-de-lapply-pour-les-générations-de-nombres-aléatoires",
    "href": "fonctions_ordre_superieur_1.html#replicate-une-variante-commode-de-lapply-pour-les-générations-de-nombres-aléatoires",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "replicate : une variante commode de lapply pour les générations de nombres aléatoires",
    "text": "replicate : une variante commode de lapply pour les générations de nombres aléatoires\nCertaines fonctions utiles en statistiques génèrent des nombres aléatoires. Par exemple, runif(2L) renvoie 2L nombres entre 0 et 1 selon une loi uniforme. Si on veut générer 4L vecteurs de 2L nombres aléatoires, on voudrait appliquer un lapply sur function() runif(2L).\nLe problème, c’est que cette fonction est sans paramètre. Du coup comment lui spécifier un lapply de bonne longueur ? On voudrait faire un truc du genre :\n\n\n\n\n\n\nMais cela n’est pas permis par R. On peut contourner le problème avec la solution ci-dessous :\n\n\n\n\n\n\nCe n’est cependant pas des plus élégants, car on utilise un argument purement fictif. Une alternative un peu plus claire existe donc. C’est la fonction replicate.\n\n\n\n\n\n\nreplicate est une variante de lapply qui permet d’évaluer une expression plusieurs fois de suite. Cela n’est, bien entendu, utile que dans le cas où cette expression renvoie des résultats différents à chaque évaluation, ce qui est notamment le cas en ce qui concerne la générations de nombres aléatoires.\nOn note l’argument simplify = FALSE à la fin. Si celui-ci n’est pas spécifié, il est par défaut défini à la valeur TRUE, et alors replicate se comporte comme un sapply ; il essaye de construire des matrices.\n\n\n\n\n\n\nNote\n\n\n\nPuisque replicate ne prend pas une fonction pour argument mais une expression, elle n’est pas stricto censu une fonction d’ordre supérieur. On la fait tout de même figurer ici car elle reste voisine d’un lapply.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#apply-appliquer-une-fonction-sur-les-lignes-ou-les-colonnes-dune-matrice",
    "href": "fonctions_ordre_superieur_1.html#apply-appliquer-une-fonction-sur-les-lignes-ou-les-colonnes-dune-matrice",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "apply : appliquer une fonction sur les lignes ou les colonnes d’une matrice",
    "text": "apply : appliquer une fonction sur les lignes ou les colonnes d’une matrice\napply permet d’appliquer une fonction par ligne ou par colonne sur une matrice.\n\n\n\n\n\n\nDans le tronçon de code ci-dessus, on a appliqué la fonction max (maximum) respectivement sur chaque ligne et chaque colonne. C’est l’argument MARGIN en deuxième position qui permet de déterminer la direction de cette application de fonction (1 pour les lignes, 2 pour les colonnes).\n\n\n\n\n\n\nNote\n\n\n\nIl est à noter que quelques optimisations de ces fonctions existent. rowSums, colSums, rowMeans, colMeans ont toutes les quatre des noms assez parlants qui permettent d’éviter une écriture un peu trop poussive.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#do.call-appliquer-une-fonction-multi-paramètres-sur-une-liste-darguments",
    "href": "fonctions_ordre_superieur_1.html#do.call-appliquer-une-fonction-multi-paramètres-sur-une-liste-darguments",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "do.call : appliquer une fonction multi-paramètres sur une liste d’arguments",
    "text": "do.call : appliquer une fonction multi-paramètres sur une liste d’arguments\nLa fonction do.call permet d’utiliser une fonction multi-paramètres, par exemple (mais pas obligatoirement) une fonction dépendant de paramètres en dots ..., sur une liste de valeurs.\n\n\n\n\n\n\nIci, on a appliqué la fonction paste en même temps sur chaque élément de la liste fournie en argument. On peut noter, également, que les éléments nommés de la liste (ici sep) sont traduits par des arguments nommés.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#reduce-réduire-une-liste-ou-un-vecteur-darguments-par-application-successive-dun-opérateur-binaire",
    "href": "fonctions_ordre_superieur_1.html#reduce-réduire-une-liste-ou-un-vecteur-darguments-par-application-successive-dun-opérateur-binaire",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "Reduce : réduire une liste ou un vecteur d’arguments par application successive d’un opérateur binaire",
    "text": "Reduce : réduire une liste ou un vecteur d’arguments par application successive d’un opérateur binaire\nLa fonction Reduce permet d’appliquer consécutivement une opération binaire.\n\n\n\n\n\n\nCet exemple (que l’on a déjà vu dans le chapitre précédent) correspond à ((1 + 2) + 8) + (-7). Chaque étape utilise l’opération binaire +.\n\n\n\n\n\n\nComme on le voit ci-dessus, on peut éventuellement, à l’aide de accumulate = TRUE, conserver les résultats intermédiaires de la réduction. À savoir ici 1, puis 1 + 2, puis 1 + 2 + 8 et enfin 1 + 2 + 8 - 7.\nMais Reduce peut être employé dans des calculs plus complexes.\n\n\n\n\n\n\nDans l’exemple précédent, on a appliqué sur une liste de fonctions l’opérateur Reduce au sens de la composition. C’est un joli exemple pour montrer la richesse d’un langage fonctionnel et illustrer l’idée que Reduce n’est pas restreint à des opérations numériques. En général, cependant, on préfèrera éviter d’empiler des fonctions non-évaluées. On préfèrera donc une notation intermédiaire comme employé ci-dessous.\n\n\n\n\n\n\nIci, plutôt que d’empiler des fonctions en mémoire, on les applique successivement. applique_fonction reste une opération binaire, mais est une loi de composition externe, dans la mesure où f est une fonction tandis que accumulateur est un résultat numérique. On remarque aussi qu’on a utilisé l’argument init de Reduce qui permet d’initialiser l’accumulateur. En effet si on veut obtenir atan(pi) / 3 + 1 il faut bien renseigner qu’on commence à pi quelque part. L’argument right = TRUE permet de parcourir la liste de droite à gauche plutôt que de gauche à droite.",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#exercices",
    "href": "fonctions_ordre_superieur_1.html#exercices",
    "title": "Fonctions d’ordre supérieur (arguments)",
    "section": "Exercices",
    "text": "Exercices\n\nQuestion 1\nÀ l’aide de la fonction pmax (sans utiliser la fonction max), calculer le maximum de cette liste. Vous pouvez consulter l’aide de la fonction pmax avec help(pmax).\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nliste &lt;- list(1, -7, 8, 0)\ndo.call(pmax, liste)\n\n[1] 8\n\n\n\n\n\n\n\nQuestion 2\nGénérer une liste avec 10 vecteurs de taille 60, chacun répartis selon une loi normale d’espérance 3 et d’écart-type 0.5. Vous pouvez consulter l’aide de la fonction rnorm via help(rnorm).\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nreplicate(10, rnorm(n=60,mean = 3,sd = 0.5), simplify = FALSE)\n\n[[1]]\n [1] 2.813906 2.198179 2.457015 3.076313 2.681320 3.810938 3.194744 2.132318\n [9] 3.125177 3.459540 2.603003 3.008595 3.060981 3.524666 2.942131 3.200121\n[17] 2.192947 3.275147 3.165462 3.612905 2.621599 2.579019 3.257388 3.355195\n[25] 3.687807 3.434291 2.796685 3.745627 2.874193 1.830705 2.945865 3.581779\n[33] 3.309020 3.170100 2.938644 3.497706 3.454699 3.037574 3.159024 2.777951\n[41] 3.256560 1.631345 3.119103 2.935754 3.384799 2.924239 3.809633 2.768908\n[49] 3.250888 3.079093 2.691609 2.543042 2.145561 3.026907 2.709592 2.399195\n[57] 3.311476 3.289225 3.701287 3.404209\n\n[[2]]\n [1] 2.968258 3.159040 3.286655 2.231492 2.258750 3.672935 3.529634 2.226709\n [9] 3.090356 2.292481 2.419118 3.095869 2.652830 2.911334 2.879195 3.820988\n[17] 3.564540 2.571851 2.860659 2.623650 2.549817 3.184359 3.567650 2.873567\n[25] 2.882900 2.749241 2.503989 3.253622 3.198276 3.394536 3.328927 2.919396\n[33] 3.056651 2.647668 3.070810 3.624250 3.198655 3.278234 3.099440 2.817727\n[41] 2.767329 3.313641 2.856341 3.130007 3.093986 3.665314 3.000901 1.914448\n[49] 3.268503 3.588794 3.057196 3.387031 3.280029 2.979658 2.763876 3.350781\n[57] 3.432004 3.677196 3.044742 2.723865\n\n[[3]]\n [1] 3.278698 3.366388 2.963444 4.013155 2.101889 2.613959 4.247509 2.317342\n [9] 3.305249 2.274026 2.461458 2.964483 3.715961 2.806525 2.554968 3.662426\n[17] 3.155115 3.178147 4.063239 3.117776 3.220565 2.785860 3.231584 3.779272\n[25] 4.021559 3.207111 3.110942 2.648502 2.784948 3.494365 3.561329 2.882054\n[33] 3.088504 3.450572 3.150873 2.762822 2.305304 2.582468 3.326500 2.526984\n[41] 2.744961 3.258329 3.424280 2.677873 2.308082 2.630056 2.801538 3.760549\n[49] 2.751528 3.439931 3.050818 3.427428 3.409298 3.100244 3.129205 3.335697\n[57] 2.710052 3.060610 3.192409 3.514929\n\n[[4]]\n [1] 2.728944 3.256423 3.362809 2.467185 2.872641 3.100293 3.305676 3.030506\n [9] 2.519339 3.303817 2.596421 2.992881 2.349872 2.966510 3.626281 3.459229\n[17] 2.908324 2.082042 3.072381 3.214516 2.526921 2.879709 3.068167 2.887842\n[25] 3.139317 2.820541 2.288002 2.025269 3.583248 3.361552 2.947428 3.259564\n[33] 2.427082 3.366231 3.390934 3.184795 3.384646 2.925112 3.258801 3.588875\n[41] 3.291707 3.450796 3.359110 3.064905 3.796078 2.456122 3.517626 2.614767\n[49] 3.394633 2.084725 3.820433 3.110197 2.624211 3.185651 3.040443 3.559246\n[57] 3.334572 2.797526 3.317473 2.507108\n\n[[5]]\n [1] 3.678743 2.607600 3.179775 2.976216 2.779570 3.130560 2.904478 2.580119\n [9] 3.231297 2.361930 3.973622 3.467413 3.079341 3.682593 3.465310 3.043269\n[17] 3.384576 3.101114 2.624600 3.290331 3.329906 3.596687 2.047598 3.649574\n[25] 3.167352 3.616911 3.341929 2.758392 2.508663 2.648313 3.189395 2.728851\n[33] 2.376678 3.070614 2.989779 3.664934 2.834911 3.427208 2.660207 2.972223\n[41] 2.226671 3.056958 3.281274 3.450092 3.040179 3.523769 2.756174 3.150646\n[49] 3.517884 3.365287 3.411507 2.582517 3.354752 3.134951 3.116600 3.692180\n[57] 3.234512 2.920046 2.735611 3.404665\n\n[[6]]\n [1] 3.608746 2.564581 2.296806 3.117074 3.267243 2.880033 2.783968 2.416066\n [9] 2.514096 3.045561 2.658272 3.313752 3.669906 3.664783 3.310063 3.562949\n[17] 2.572923 3.161317 2.496066 4.259673 3.074312 3.310903 3.341404 3.510297\n[25] 3.221988 3.288552 3.451753 2.832613 3.238818 2.856796 2.500503 3.660274\n[33] 2.208543 2.697448 2.685379 3.560753 2.866118 3.165340 3.558361 3.357888\n[41] 2.782070 3.034184 3.422981 2.563438 3.338976 2.750821 3.237047 4.392303\n[49] 2.762853 3.610379 3.551158 2.874329 3.356317 3.758300 2.375589 2.879223\n[57] 3.079080 3.019524 2.450394 3.344171\n\n[[7]]\n [1] 3.377052 3.228265 2.883942 3.957270 2.546479 2.290485 2.545508 2.752544\n [9] 3.588362 3.662550 2.248344 2.865519 3.014902 3.173186 3.643466 3.509600\n[17] 2.792460 2.825812 3.239990 3.482774 2.034316 2.511993 3.294528 3.245934\n[25] 3.798622 3.340864 3.092519 3.352769 3.170500 3.522417 2.713457 3.022942\n[33] 4.158408 3.219736 2.143628 3.698459 3.249295 2.991045 3.752077 3.267521\n[41] 3.382436 3.264970 3.220645 1.955230 3.070347 2.996828 2.837059 2.685571\n[49] 2.311109 2.912033 2.224641 2.990674 3.211150 3.623698 3.359503 3.441249\n[57] 3.128171 3.076375 2.726372 2.097007\n\n[[8]]\n [1] 2.462642 3.218703 3.885480 2.848857 3.878213 2.581799 2.251266 3.081597\n [9] 3.183013 3.244079 3.141294 2.781299 3.300647 3.454212 3.496543 2.826699\n[17] 3.032130 2.204350 3.850014 2.650079 2.737692 2.923681 3.215239 3.201780\n[25] 2.581103 2.222906 2.885415 3.996335 3.029950 1.897832 2.488550 2.556431\n[33] 3.298889 3.636925 2.676162 3.108595 3.249167 3.497597 2.816249 2.876875\n[41] 3.539284 3.003862 2.805694 2.074171 2.581323 2.244603 2.556268 2.163412\n[49] 3.417080 3.003199 2.849378 2.194022 3.007373 2.953515 4.017897 3.538928\n[57] 2.555661 2.878084 3.549963 2.685996\n\n[[9]]\n [1] 3.478874 2.572281 2.829249 3.492144 3.090758 2.891627 3.244543 3.359446\n [9] 3.092888 2.331047 2.162396 2.921849 3.313416 2.730671 3.417143 3.379420\n[17] 3.095195 2.863016 3.466475 3.471343 2.635497 1.894010 4.131847 2.404313\n[25] 4.304776 2.762302 3.161137 2.406429 2.896330 3.101544 2.952389 2.805072\n[33] 2.790209 3.189965 2.986761 3.079763 2.392650 3.511190 2.713743 3.711189\n[41] 3.173171 3.522410 3.855187 2.833860 2.885730 3.186924 3.096824 3.365370\n[49] 3.648205 1.659049 3.358470 3.325161 3.063058 3.230267 3.637310 2.996438\n[57] 3.386700 2.372582 2.860248 2.735944\n\n[[10]]\n [1] 2.949256 2.442608 1.967177 3.326041 2.383966 3.481693 2.626200 3.171057\n [9] 3.249215 3.433215 2.742169 2.110446 3.811018 3.832554 2.684775 3.917378\n[17] 3.264018 2.553194 3.271590 2.448373 2.647945 2.631340 2.583642 1.667438\n[25] 3.309249 2.097774 3.116490 3.354955 2.919450 3.495867 3.066565 2.873467\n[33] 3.229014 2.758453 2.291803 1.778109 1.752606 3.783714 3.425820 2.969724\n[41] 3.128569 3.433510 3.078625 2.759311 3.304842 1.194164 2.622433 2.374734\n[49] 3.448043 3.121005 2.977603 2.967202 3.116161 3.183747 2.253139 3.252574\n[57] 2.878581 2.969231 2.586467 2.594435\n\n\n\n\n\n\n\nQuestion 3\nÀ l’aide de la fonction paste0 (qui est comme la fonction paste mais avec l’argument par défaut sep = \"\"), produire la chaine de caractère \"aabbccddeeffgg (...) xxyyzz\". Les lettres en minuscules sont accessibles via letters.\n\n\n\n\n\n\n\n\n\n\n\n\nPropositions de solution\n\n\n\n\n\n\ndo.call(paste0, Map(paste0, letters, letters))\n\n[1] \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"\n\n# ou\n\ndo.call(paste0, as.list(rep(letters, each = 2)))\n\n[1] \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"\n\n# ou plus simplement\n\npaste0(rep(letters, each = 2), collapse = \"\")\n\n[1] \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"\n\n\n\n\n\n\n\nQuestion 4\nObserver cette matrice des permutations en colonnes de 1L:5L :\n\nvecteur &lt;- 1L:5L\nmatrix(\n  c(tail(vecteur, 5L),\n    tail(vecteur, 4L), head(vecteur, 1L),\n    tail(vecteur, 3L), head(vecteur, 2L),\n    tail(vecteur, 2L), head(vecteur, 3L),\n    tail(vecteur, 1L), head(vecteur, 4L)),\n  nrow = length(vecteur),\n  ncol = length(vecteur))\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    2    3    4    5    1\n[3,]    3    4    5    1    2\n[4,]    4    5    1    2    3\n[5,]    5    1    2    3    4\n\n\nPouvez-vous généraliser cette création de matrice à n’importe quel vecteur d’entiers ? Pour ce faire, construisez une fonction super_matrice dont l’unique paramètre est vecteur.\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nvecteur &lt;- 1L:5L\nsuper_matrice &lt;- function(vecteur) {\n  longueur &lt;- length(vecteur)\n  vapply(0L:(longueur - 1L),\n         \\(n) c(tail(vecteur, longueur - n), head(vecteur, n)),\n         rep(0L,longueur))\n}\nsuper_matrice(vecteur)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    2    3    4    5    1\n[3,]    3    4    5    1    2\n[4,]    4    5    1    2    3\n[5,]    5    1    2    3    4\n\n\n\n\n\n\n\nQuestion 5\nProposer une version du crible d’Eratosthène faisant apparaître, pour un entier n donné, un vecteur booléen de taille n donnant la primalité (ou non) de l’entier i.\nPar exemple, crible(10) donne c(FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE). En effet 1 n’est pas premier, 2 est premier, 3 est premier…\nOn pourra utiliser la fonction Reduce.\n\n\n\n\n\n\n\n\n\n\n\n\nAide 1 (conseillée !)\n\n\n\n\n\nEssayer, dans un premier temps, d’obtenir une fonction est_multiple avec i pour argument et un n fixé à l’avance dans l’environnement global, un vecteur :\n\nde taille n\nvalant TRUE sur les multiples de i\nvalant FALSE ailleurs\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nn &lt;- 10L\nest_multiple &lt;- function(i) 1L:n %% i == 0L\nest_multiple(2L)\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAide 2 (optionnel mais à ne pas consulter avant 5 minutes de brainstorming !)\n\n\n\n\n\nEssayer, dans un premier temps, d’obtenir une fonction ni_multiple_ni_i avec i pour argument et un n fixé à l’avance dans l’environnement global, un vecteur :\n\nde taille n\nvalant TRUE sur i\nvalant FALSE sur les autres multiples de i\nvalant TRUE ailleurs\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nn &lt;- 10L\nni_multiple_ni_i &lt;- function(i) 1L:n == i | 1L:n %% i != 0L\nni_multiple_ni_i(2L)\n\n [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\ncrible &lt;- function(n) {\n  Reduce(`&`,\n         lapply(2L:sqrt(n), \\(i) 1L:n == i | 1L:n %% i != 0L),\n         init = c(FALSE, rep(TRUE, n - 1L)))\n}\ncrible(10L)\n\n [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE",
    "crumbs": [
      "Fonctions d'ordre supérieur (arguments)"
    ]
  },
  {
    "objectID": "poo_s3.html",
    "href": "poo_s3.html",
    "title": "Programmation fonctionnelle objet en R (S3)",
    "section": "",
    "text": "Comme on l’a vu dans la page d’introduction, S3 est un système de programmation orientée objet dans R, adapté par rapport aux autres langages pour être soluble au paradigme prédominant dans R, à savoir la programmation fonctionnelle.\nDans R, le système de Programmation Orientée Objet S3 est structuré par :\n\ndes fonction génériques qui sont simplement des noms de fonctions munis d’une description abstraite en langage naturel. Par exemple summary() est une fonction générique. Sa description abstraite est décrite par l’aide accessible via ?summary. On y trouve “summary is a generic function used to produce result summaries of the results of various model fitting functions. The function invokes particular methods which depend on the class of the first argument.”. À charge des différents concepteurs d’objets de lui donner un sens particulier conforme à cette description abstraite.\ndes classes d’objets qui sont simplement des étiquettes portées par l’objet et montrées à la fonction générique. Par exemple, si objet est un objet de classe twoStepsBenchmark du package disaggR, il montrera une étiquette \"twoStepsBenchmark\" à la fonction summary(). Un objet tibble montrera une étiquette \"tbl_df\" à la fonction summary() (\"tbl_df\" est le vrai nom de la classe des tibbles).\ndes méthodes qui écrivent explicitement le code utilisé pour une fonction dans le cas d’une classe d’objet (on peut dire qu’on implémente summary() quand on en écrit explicitement son code pour une classe précise). Par exemple summary() renverra vers summary.twoStepsBenchmark() pour un objet de classe twoStepsBenchmark, tandis qu’elle essayera en premier de renvoyer vers summary.tbl_df() pour un tibble.\nUn héritage entre classes d’objets qui dit simplement que si une méthode n’existe pas pour une fonction générique, alors on en cherche une autre, puis une autre, et ainsi de suite. Par exemple un tibble a en fait 3 étiquettes, c(\"tbl_df\", \"tbl\", \"data.frame\"). On cherchera d’abord truc.tbl_df, puis truc.tbl, puis truc.data.frame. En ce qui concerne la fonction summary(), on cherche d’abord une fonction summary.tbl_df() (qui n’existe pas), puis une fonction summary.tbl() (qui n’existe pas non plus), et enfin une fonction summary.data.frame() (qui existe ! Bingo ! C’est la méthode utilisée.).\n\nUsuellement, un système de Programmation Orientée Objet structure le code en faisant appel à des instances d’objets sur lesquelles on appelle des méthodes. Plus spécifiquement, on a :\n\nUne instance d’objet, par exemple la baguette magique que j’ai en main en écrivant ces lignes.\nUne classe d’objet, par exemple celle des baguettes magiques. Toutes les instances de baguettes magiques se comportent exactement de la même manière, mais peuvent avoir différents attibuts (longueur, bois utilisé…).\nDes méthodes, à savoir les choses que l’on peut faire avec une classe d’objets. Par exemple en ce qui concerne les baguettes magiques, considérons jeter_boule_de_feu(), et faire_pleuvoir().\nUn héritage, à savoir que chaque classe a une classe parente dont elle étend les possibilités. Une baguette magique est un type particulier de bâton de bois. La classe des “baguettes magiques” hérite de l’ensemble des méthodes des “bâtons de bois”. On peut toujours taper_sur_un_ennemi(), faire_un_feu_de_camp(), casser_en_deux() avec une baguette magique.\n\nOn remarque que S3 préserve un peu cette structuration générale, mais l’adapte. Les éléments de POO sont tordus pour correspondre au paradigme prédominant qui est le paradigme fonctionnel. Voici les changements notables :\n\nOn centre sur les fonctions plutôt que les classes d’objets. Au lieu de s’attarder sur une classe puis de décrire les méthodes/fonctions que l’on peut appliquer dessus, dans S3 on fait exactement l’inverse ; on énonce un nom de fonction puis on écrit comment cette fonction s’applique sur différents objets. On a d’abord la fonction générique faire_pleuvoir(objet). On l’implémente en faire_pleuvoir.baguette_magique(objet) qui est la méthode faire_pleuvoir() adaptée aux baguettes magiques. On peut ensuite implémenter également faire_pleuvoir.robot_chanteur(objet) si on veut prévoir une méthode faire_pleuvoir() adaptée aux robots chanteurs.\nIl n’y a pas de notion d’instance d’objet. La notion d’instance d’objet induit une notion d’unicité et d’état interne, comme on l’a vu au chapitre précédent. Si on copiait compteur_1 dans compteur_1bis, c’était le même compteur. Il n’y a pas de système d’instance natif à S3 ; i on veut des instances, il faut les créer manu-militari de la même manière qu’on l’a déjà fait (c’est l’objet de l’exercice 2 de ce classeur).",
    "crumbs": [
      "Programmation fonctionnelle objet en R (S3)"
    ]
  },
  {
    "objectID": "poo_s3.html#introduction-s3-et-la-programmation-orientée-objet",
    "href": "poo_s3.html#introduction-s3-et-la-programmation-orientée-objet",
    "title": "Programmation fonctionnelle objet en R (S3)",
    "section": "",
    "text": "Comme on l’a vu dans la page d’introduction, S3 est un système de programmation orientée objet dans R, adapté par rapport aux autres langages pour être soluble au paradigme prédominant dans R, à savoir la programmation fonctionnelle.\nDans R, le système de Programmation Orientée Objet S3 est structuré par :\n\ndes fonction génériques qui sont simplement des noms de fonctions munis d’une description abstraite en langage naturel. Par exemple summary() est une fonction générique. Sa description abstraite est décrite par l’aide accessible via ?summary. On y trouve “summary is a generic function used to produce result summaries of the results of various model fitting functions. The function invokes particular methods which depend on the class of the first argument.”. À charge des différents concepteurs d’objets de lui donner un sens particulier conforme à cette description abstraite.\ndes classes d’objets qui sont simplement des étiquettes portées par l’objet et montrées à la fonction générique. Par exemple, si objet est un objet de classe twoStepsBenchmark du package disaggR, il montrera une étiquette \"twoStepsBenchmark\" à la fonction summary(). Un objet tibble montrera une étiquette \"tbl_df\" à la fonction summary() (\"tbl_df\" est le vrai nom de la classe des tibbles).\ndes méthodes qui écrivent explicitement le code utilisé pour une fonction dans le cas d’une classe d’objet (on peut dire qu’on implémente summary() quand on en écrit explicitement son code pour une classe précise). Par exemple summary() renverra vers summary.twoStepsBenchmark() pour un objet de classe twoStepsBenchmark, tandis qu’elle essayera en premier de renvoyer vers summary.tbl_df() pour un tibble.\nUn héritage entre classes d’objets qui dit simplement que si une méthode n’existe pas pour une fonction générique, alors on en cherche une autre, puis une autre, et ainsi de suite. Par exemple un tibble a en fait 3 étiquettes, c(\"tbl_df\", \"tbl\", \"data.frame\"). On cherchera d’abord truc.tbl_df, puis truc.tbl, puis truc.data.frame. En ce qui concerne la fonction summary(), on cherche d’abord une fonction summary.tbl_df() (qui n’existe pas), puis une fonction summary.tbl() (qui n’existe pas non plus), et enfin une fonction summary.data.frame() (qui existe ! Bingo ! C’est la méthode utilisée.).\n\nUsuellement, un système de Programmation Orientée Objet structure le code en faisant appel à des instances d’objets sur lesquelles on appelle des méthodes. Plus spécifiquement, on a :\n\nUne instance d’objet, par exemple la baguette magique que j’ai en main en écrivant ces lignes.\nUne classe d’objet, par exemple celle des baguettes magiques. Toutes les instances de baguettes magiques se comportent exactement de la même manière, mais peuvent avoir différents attibuts (longueur, bois utilisé…).\nDes méthodes, à savoir les choses que l’on peut faire avec une classe d’objets. Par exemple en ce qui concerne les baguettes magiques, considérons jeter_boule_de_feu(), et faire_pleuvoir().\nUn héritage, à savoir que chaque classe a une classe parente dont elle étend les possibilités. Une baguette magique est un type particulier de bâton de bois. La classe des “baguettes magiques” hérite de l’ensemble des méthodes des “bâtons de bois”. On peut toujours taper_sur_un_ennemi(), faire_un_feu_de_camp(), casser_en_deux() avec une baguette magique.\n\nOn remarque que S3 préserve un peu cette structuration générale, mais l’adapte. Les éléments de POO sont tordus pour correspondre au paradigme prédominant qui est le paradigme fonctionnel. Voici les changements notables :\n\nOn centre sur les fonctions plutôt que les classes d’objets. Au lieu de s’attarder sur une classe puis de décrire les méthodes/fonctions que l’on peut appliquer dessus, dans S3 on fait exactement l’inverse ; on énonce un nom de fonction puis on écrit comment cette fonction s’applique sur différents objets. On a d’abord la fonction générique faire_pleuvoir(objet). On l’implémente en faire_pleuvoir.baguette_magique(objet) qui est la méthode faire_pleuvoir() adaptée aux baguettes magiques. On peut ensuite implémenter également faire_pleuvoir.robot_chanteur(objet) si on veut prévoir une méthode faire_pleuvoir() adaptée aux robots chanteurs.\nIl n’y a pas de notion d’instance d’objet. La notion d’instance d’objet induit une notion d’unicité et d’état interne, comme on l’a vu au chapitre précédent. Si on copiait compteur_1 dans compteur_1bis, c’était le même compteur. Il n’y a pas de système d’instance natif à S3 ; i on veut des instances, il faut les créer manu-militari de la même manière qu’on l’a déjà fait (c’est l’objet de l’exercice 2 de ce classeur).",
    "crumbs": [
      "Programmation fonctionnelle objet en R (S3)"
    ]
  },
  {
    "objectID": "poo_s3.html#s3-en-pratique",
    "href": "poo_s3.html#s3-en-pratique",
    "title": "Programmation fonctionnelle objet en R (S3)",
    "section": "S3 en pratique",
    "text": "S3 en pratique\nPour voir les classes d’un objet, on utilise la fonction class().\n\n\n\n\n\n\nOn remarque que :\n\nUn objet créé par twoStepsBenchmark() hérite de la classe \"twoStepsBenchmark\".\nUn tibble herite de la classe \"tbl_df\", puis \"tbl\", puis \"data.frame\".\n\nUne classe S3 est une étiquette apposée sur des données dont le type peut être consulté à l’aide de typeof() :\n\n\n\n\n\n\nOn vérifie ainsi qu’aussi bien la classe twoStepsBenchmark que celle des tibbles sont basées sur des données stockées sous forme de liste.\nOn peut vérifier si un objet hérite d’une classe avec la fonction inherits() :\n\n\n\n\n\n\nOn identifie une fonction générique S3 par le fait que son corps se limite à un UseMethod(\"nom_de_la_fonction\").\n\n\n\n\n\n\nDans l’exemple ci-dessus, on voit que la fonction summary n’est définie par rien d’autre que :\n\nsummary &lt;- function(object, ...) UseMethod(\"summary\")\n\nC’est assez succinct ! Cela déclare summary comme une fonction générique, et dit d’aller chercher la bonne méthode selon la classe du premier argument (ici object).\nPour voir les méthodes proposées par une fonction générique, on utilise methods() :\n\n\n\n\n\n\nIl y a un paquet de méthodes implémentées pour summary() dites-donc ! Certaines méthodes ont une étoile derrière leur nom, certaines n’ont pas d’étoile. Pour consulter le code d’une méthode sans étoile, il suffit de taper son nom.\n\n\n\n\n\n\nCes méthodes correspondent à des fonctions exportées par les packages (ou par r-base). C’est-à-dire que leur concepteur a tenu à les rendre disponibles aux utilisateurs. Elles peuvent très bien être utilisées avec leur propre nom si on ne souhaite pas passer par la générique.\n\n\n\n\n\n\nLes méthodes ans étoiles derrière leur nom correspondent à des méthodes non-exportées par un package, c’est-à-dire que l’auteur du package n’a pas jugé utile de les rendre directement accessibles à l’utilisateur et privilégie l’emploi de la générique.\n\n\n\n\n\n\nOn peut quand même lire ces méthodes et savoir d’où elles viennent en utilisant getAnywhere().\n\n\n\n\n\n\nIci, on lit que la méthode summary.twoStepsBenchmark existe de manière interne au package disaggR et que son code est :\n\nsummary.twoStepsBenchmark &lt;- function (object, ...) {\n  summary.praislm(prais(object), ...)\n}\n\nAutrement dit, elle renvoie encore à une autre méthode de summary.\n\n\n\n\n\n\nNote\n\n\n\nOn peut accéder à toutes les fonctions d’un package, y compris les fonctions non-exportées, à l’aide des triples doubles-points (:::). Par exemple, on peut accéder à summary.twoStepsBenchmark en écrivant :\n\n\n\n\n\n\nBien sûr, inutile de vous prévenir que ce n’est pas une bonne pratique dans du code de production. R est très permissif, mais c’est à l’utilisateur de se discipliner. Si l’auteur d’un package a choisi de ne pas dire à l’utilisateur “tu peux utiliser cette fonction directement”, c’est à nos risques et périls si on le fait quand même !\n\n\nOn peut également utiliser methods() pour chercher toutes les méthodes associées à une classe :",
    "crumbs": [
      "Programmation fonctionnelle objet en R (S3)"
    ]
  },
  {
    "objectID": "poo_s3.html#attributs",
    "href": "poo_s3.html#attributs",
    "title": "Programmation fonctionnelle objet en R (S3)",
    "section": "Attributs",
    "text": "Attributs\nN’importe quel objet peut se voir affecter un nombre quelquonque d’autres objets nommés appelés attributs. Ceux-ci peuvent être accedés à l’aide de la fonction attributes() qui renvoie une liste nommée.\n\n\n\n\n\n\nLe tibble starwars a trois attributs :\n\nnames qui stocke les noms de colonne\nrow.names qui stocke les noms de ligne, et qui correspond ici simplement à des numéros car un tibble n’a pas de noms de lignes (l’attribut row.names est hérité des objets data.frame)\nclass qui contient les classes de dplyr::starwars.\n\nOn voit donc qu’un objet classé selon le système S3 n’est rien d’autre qu’un objet avec un attribut “class”.\nLes attributs peuvent être accedés et affectés de différentes manières.\n\n\n\n\n\n\nCi-dessus, avec la fonction structure(), on a créé en un coup l’objet avec ses deux attributs class et mon_attribut.\nOn aurait pu également les affecter un par un comme on le voit ci-dessous.",
    "crumbs": [
      "Programmation fonctionnelle objet en R (S3)"
    ]
  },
  {
    "objectID": "poo_s3.html#ma-première-classe-s3",
    "href": "poo_s3.html#ma-première-classe-s3",
    "title": "Programmation fonctionnelle objet en R (S3)",
    "section": "Ma première classe S3",
    "text": "Ma première classe S3\nDéfinir une fonction vecteur_titre() qui :\n\nPrend deux arguments, à savoir un vecteur x et un argument titre (qui est un character de taille 1).\nRetourne le vecteur x, à qui on a affecté la classe vecteur_avec_titre ainsi qu’un attribut titre égal à l’argument titre.\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nvecteur_titre &lt;- function(x, titre) {\n  structure(x,\n            class = \"vecteur_avec_titre\",\n            titre = titre)\n}\n\n\n\n\nEssayer ce constructeur sur vecteur_titre(1:10, \"Les 10 premiers entiers\") dont les attributs retournés par attributes doivent logiquement correspondre à :\n\n\n$class\n[1] \"vecteur_avec_titre\"\n\n$titre\n[1] \"Les 10 premiers entiers\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nvecteur_titre &lt;- function(x, titre) {\n  structure(x,\n            class = \"vecteur_avec_titre\",\n            titre = titre)\n}\nmon_vecteur &lt;- vecteur_titre(1:10, \"Les 10 premiers entiers\")\nattributes(mon_vecteur)\n\n$class\n[1] \"vecteur_avec_titre\"\n\n$titre\n[1] \"Les 10 premiers entiers\"\n\n\n\n\n\nAprès avoir saisi mon_vecteur &lt;- vecteur_titre(1:10, \"Les 10 premiers entiers\")… Si je tape mon_vecteur dans R (ou dans la console si je suis sous RStudio), c’est très moche ! Je lis en effet :\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\nattr(,\"class\")\n[1] \"vecteur_avec_titre\"\nattr(,\"titre\")\n[1] \"Les 10 premiers entiers\"\n\n\nLa fonction qui est utilisée pour afficher un objet S3 lors de la saisie de celui-ci est la fonction print(). Vérifier que print() correspond à une fonction générique et afficher les méthodes associées.\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\nIl suffit de taper :\n\nprint\n\nfunction (x, ...) \nUseMethod(\"print\")\n&lt;bytecode: 0x55e93bd72780&gt;\n&lt;environment: namespace:base&gt;\n\n\npour vérifier que la fonction print est bien générique (elle utilise UseMethod(\"print\")).\nOn peut en afficher les méthodes en tapant :\n\nmethods(print)\n\n  [1] print.acf*                                          \n  [2] print.activeConcordance*                            \n  [3] print.AES*                                          \n  [4] print.anova*                                        \n  [5] print.aov*                                          \n  [6] print.aovlist*                                      \n  [7] print.ar*                                           \n  [8] print.Arima*                                        \n  [9] print.arima0*                                       \n [10] print.AsIs                                          \n [11] print.aspell*                                       \n [12] print.aspell_inspect_context*                       \n [13] print.bibentry*                                     \n [14] print.Bibtex*                                       \n [15] print.browseVignettes*                              \n [16] print.by                                            \n [17] print.changedFiles*                                 \n [18] print.check_bogus_return*                           \n [19] print.check_code_usage_in_package*                  \n [20] print.check_compiled_code*                          \n [21] print.check_demo_index*                             \n [22] print.check_depdef*                                 \n [23] print.check_details*                                \n [24] print.check_details_changes*                        \n [25] print.check_doi_db*                                 \n [26] print.check_dotInternal*                            \n [27] print.check_make_vars*                              \n [28] print.check_nonAPI_calls*                           \n [29] print.check_package_code_assign_to_globalenv*       \n [30] print.check_package_code_attach*                    \n [31] print.check_package_code_data_into_globalenv*       \n [32] print.check_package_code_startup_functions*         \n [33] print.check_package_code_syntax*                    \n [34] print.check_package_code_unload_functions*          \n [35] print.check_package_compact_datasets*               \n [36] print.check_package_CRAN_incoming*                  \n [37] print.check_package_datalist*                       \n [38] print.check_package_datasets*                       \n [39] print.check_package_depends*                        \n [40] print.check_package_description*                    \n [41] print.check_package_description_encoding*           \n [42] print.check_package_license*                        \n [43] print.check_packages_in_dir*                        \n [44] print.check_packages_used*                          \n [45] print.check_po_files*                               \n [46] print.check_pragmas*                                \n [47] print.check_Rd_line_widths*                         \n [48] print.check_Rd_metadata*                            \n [49] print.check_Rd_xrefs*                               \n [50] print.check_RegSym_calls*                           \n [51] print.check_S3_methods_needing_delayed_registration*\n [52] print.check_so_symbols*                             \n [53] print.check_T_and_F*                                \n [54] print.check_url_db*                                 \n [55] print.check_vignette_index*                         \n [56] print.checkDocFiles*                                \n [57] print.checkDocStyle*                                \n [58] print.checkFF*                                      \n [59] print.checkRd*                                      \n [60] print.checkRdContents*                              \n [61] print.checkReplaceFuns*                             \n [62] print.checkS3methods*                               \n [63] print.checkTnF*                                     \n [64] print.checkVignettes*                               \n [65] print.citation*                                     \n [66] print.cli_ansi_html_style*                          \n [67] print.cli_ansi_string*                              \n [68] print.cli_ansi_style*                               \n [69] print.cli_boxx*                                     \n [70] print.cli_diff_chr*                                 \n [71] print.cli_doc*                                      \n [72] print.cli_progress_demo*                            \n [73] print.cli_rule*                                     \n [74] print.cli_sitrep*                                   \n [75] print.cli_spark*                                    \n [76] print.cli_spinner*                                  \n [77] print.cli_tree*                                     \n [78] print.codoc*                                        \n [79] print.codocClasses*                                 \n [80] print.codocData*                                    \n [81] print.colorConverter*                               \n [82] print.compactPDF*                                   \n [83] print.condition                                     \n [84] print.connection                                    \n [85] print.CRAN_package_reverse_dependencies_and_views*  \n [86] print.data.frame                                    \n [87] print.Date                                          \n [88] print.default                                       \n [89] print.dendrogram*                                   \n [90] print.density*                                      \n [91] print.difftime                                      \n [92] print.dist*                                         \n [93] print.Dlist                                         \n [94] print.DLLInfo                                       \n [95] print.DLLInfoList                                   \n [96] print.DLLRegisteredRoutines                         \n [97] print.dummy_coef*                                   \n [98] print.dummy_coef_list*                              \n [99] print.ecdf*                                         \n[100] print.eigen                                         \n[101] print.factanal*                                     \n[102] print.factor                                        \n[103] print.family*                                       \n[104] print.fileSnapshot*                                 \n[105] print.findLineNumResult*                            \n[106] print.formula*                                      \n[107] print.ftable*                                       \n[108] print.function                                      \n[109] print.getAnywhere*                                  \n[110] print.glm*                                          \n[111] print.hashtab*                                      \n[112] print.hclust*                                       \n[113] print.help_files_with_topic*                        \n[114] print.hexmode                                       \n[115] print.HoltWinters*                                  \n[116] print.hsearch*                                      \n[117] print.hsearch_db*                                   \n[118] print.htest*                                        \n[119] print.html*                                         \n[120] print.html_dependency*                              \n[121] print.htmltools.selector*                           \n[122] print.htmltools.selector.list*                      \n[123] print.infl*                                         \n[124] print.integrate*                                    \n[125] print.isoreg*                                       \n[126] print.json*                                         \n[127] print.key_missing*                                  \n[128] print.kmeans*                                       \n[129] print.knitr_kable*                                  \n[130] print.Latex*                                        \n[131] print.LaTeX*                                        \n[132] print.libraryIQR                                    \n[133] print.listof                                        \n[134] print.lm*                                           \n[135] print.loadings*                                     \n[136] print.loess*                                        \n[137] print.logLik*                                       \n[138] print.ls_str*                                       \n[139] print.medpolish*                                    \n[140] print.MethodsFunction*                              \n[141] print.mtable*                                       \n[142] print.NativeRoutineList                             \n[143] print.news_db*                                      \n[144] print.nls*                                          \n[145] print.noquote                                       \n[146] print.numeric_version                               \n[147] print.object_size*                                  \n[148] print.octmode                                       \n[149] print.packageDescription*                           \n[150] print.packageInfo                                   \n[151] print.packageIQR*                                   \n[152] print.packageStatus*                                \n[153] print.pairwise.htest*                               \n[154] print.person*                                       \n[155] print.POSIXct                                       \n[156] print.POSIXlt                                       \n[157] print.power.htest*                                  \n[158] print.ppr*                                          \n[159] print.prcomp*                                       \n[160] print.princomp*                                     \n[161] print.proc_time                                     \n[162] print.quosure*                                      \n[163] print.quosures*                                     \n[164] print.raster*                                       \n[165] print.Rconcordance*                                 \n[166] print.Rd*                                           \n[167] print.recordedplot*                                 \n[168] print.restart                                       \n[169] print.RGBcolorConverter*                            \n[170] print.RGlyphFont*                                   \n[171] print.rlang_box_done*                               \n[172] print.rlang_box_splice*                             \n[173] print.rlang_data_pronoun*                           \n[174] print.rlang_dict*                                   \n[175] print.rlang_dyn_array*                              \n[176] print.rlang_envs*                                   \n[177] print.rlang_error*                                  \n[178] print.rlang_fake_data_pronoun*                      \n[179] print.rlang_lambda_function*                        \n[180] print.rlang_message*                                \n[181] print.rlang_trace*                                  \n[182] print.rlang_warning*                                \n[183] print.rlang_zap*                                    \n[184] print.rlang:::list_of_conditions*                   \n[185] print.rle                                           \n[186] print.rlib_bytes*                                   \n[187] print.rlib_error_3_0*                               \n[188] print.rlib_trace_3_0*                               \n[189] print.roman*                                        \n[190] print.scalar*                                       \n[191] print.sessionInfo*                                  \n[192] print.shiny.tag*                                    \n[193] print.shiny.tag.env*                                \n[194] print.shiny.tag.list*                               \n[195] print.shiny.tag.query*                              \n[196] print.simple.list                                   \n[197] print.smooth.spline*                                \n[198] print.socket*                                       \n[199] print.srcfile                                       \n[200] print.srcref                                        \n[201] print.stepfun*                                      \n[202] print.stl*                                          \n[203] print.StructTS*                                     \n[204] print.subdir_tests*                                 \n[205] print.summarize_CRAN_check_status*                  \n[206] print.summary.aov*                                  \n[207] print.summary.aovlist*                              \n[208] print.summary.ecdf*                                 \n[209] print.summary.glm*                                  \n[210] print.summary.lm*                                   \n[211] print.summary.loess*                                \n[212] print.summary.manova*                               \n[213] print.summary.nls*                                  \n[214] print.summary.packageStatus*                        \n[215] print.summary.ppr*                                  \n[216] print.summary.prcomp*                               \n[217] print.summary.princomp*                             \n[218] print.summary.table                                 \n[219] print.summary.warnings                              \n[220] print.summaryDefault                                \n[221] print.table                                         \n[222] print.tables_aov*                                   \n[223] print.terms*                                        \n[224] print.ts*                                           \n[225] print.tskernel*                                     \n[226] print.TukeyHSD*                                     \n[227] print.tukeyline*                                    \n[228] print.tukeysmooth*                                  \n[229] print.undoc*                                        \n[230] print.vignette*                                     \n[231] print.warnings                                      \n[232] print.xfun_raw_string*                              \n[233] print.xfun_record_results*                          \n[234] print.xfun_rename_seq*                              \n[235] print.xfun_strict_list*                             \n[236] print.xgettext*                                     \n[237] print.xngettext*                                    \n[238] print.xtabs*                                        \nsee '?methods' for accessing help and source code\n\n\nEt il y en a beaucoup ! C’est normal, tous les objets veulent définir une manière de s’afficher.\n\n\n\nDéfinir une fonction print.vecteur_avec_titre qui vaut :\n\nprint.vecteur_avec_titre &lt;- function(x, ...) { # Les paramètres doivent être compatibles avec ceux de la fonction générique, d'où les ...\n  cat(attr(x, \"titre\"), \":\\n\") # \\n correspond à un saut de ligne\n  cat(as.vector(x))\n  # cat est une fonction qui permet d'écrire dans la console\n}\n\nPuis taper mon_vecteur pour vérifier ce qu’il se passe.\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nprint.vecteur_avec_titre &lt;- function(x, ...) { # Les paramètres doivent être compatibles avec ceux de la fonction générique, d'où les ...\n  cat(attr(x, \"titre\"), \":\\n\") # \\n correspond à un saut de ligne\n  cat(as.vector(x))\n  # cat est une fonction qui permet d'écrire dans la console\n}\nmon_vecteur\n\nLes 10 premiers entiers :\n1 2 3 4 5 6 7 8 9 10\n\n\nOn a implémenté la fonction générique print() par une *méthode* adaptée à la *classe*“vecteur_avec_titre”`. Dorénavant, l’affichage est plus propre.\n\n\n\nOn a donc créé notre propre méthode S3 à une fonction générique pré-existante. On veut aller plus loin et créer notre propre fonction générique. On veut :\n\nune fonction générique get_titre qui n’ait que pour argument x.\nElle doit avoir une méthode get_titre.vecteur_avec_titre qui retourne le titre.\nElle doit avoir une méthode get_titre.tbl_df qui lance stop(\"Un tibble n'a pas de titre !\").\n\nTester ensuite cette fonction par get_titre(mon_vecteur) et get_titre(dplyr::starwars).\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nget_titre &lt;- function(x) UseMethod(\"get_titre\")\nget_titre.vecteur_avec_titre &lt;- function(x) attr(x, \"titre\")\nget_titre.tbl_df &lt;- function(x) stop(\"Un tibble n'a pas de titre !\")\nget_titre(mon_vecteur)\n\n[1] \"Les 10 premiers entiers\"\n\nget_titre(dplyr::starwars)\n\nError in get_titre.tbl_df(dplyr::starwars): Un tibble n'a pas de titre !\n\n\nOn a donc ici créé une fonction générique, et on l’a implémenté par deux méthodes. Une pour vecteur_avec_titre, et une autre plus succinte pour les tibble, qui dirige vers une erreur.",
    "crumbs": [
      "Programmation fonctionnelle objet en R (S3)"
    ]
  },
  {
    "objectID": "poo_s3.html#exercices",
    "href": "poo_s3.html#exercices",
    "title": "Programmation fonctionnelle objet en R (S3)",
    "section": "Exercices",
    "text": "Exercices\n\nExercice 1\nUtiliser la fonction attributes() pour retourner les attributs d’un vecteur c(arnaud=1, bonjour=2). Comment sont stockés les noms dans un vecteur nommé ?\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nattributes(c(arnaud=1, bonjour=2))\n\n$names\n[1] \"arnaud\"  \"bonjour\"\n\n\nOn voit qu’un vecteur nommé n’est rien de plus qu’un vecteur avec un attribut names.\n\n\n\nSoit la matrice définie par :\n\nmatrice &lt;- matrix(1L:12L, nrow = 3L, ncol = 4L)\ncolnames(matrice) &lt;- c(\"les\", \"noms\", \"de\", \"colonnes\")\nrownames(matrice) &lt;- c(\"voilà\", \"des\", \"lignes\")\n\nUtiliser la fonction typeof() pour voir le type des données d’une matrice. Utiliser la fonction attributes() pour retourner les attributs de cette matrice. Comment sont stockées les dimensions dans une matrice ? Comment sont stockés les noms de colonnes et de dans une matrice ? Y a-t-il un attribut class dans une matrice ? Est-ce que pour autant inherits(matrice, \"matrix\") renvoie FALSE ?\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nmatrice &lt;- matrix(1L:12L, nrow = 3L, ncol = 4L)\ntypeof(matrice)\n\n[1] \"integer\"\n\ncolnames(matrice) &lt;- c(\"les\", \"noms\", \"de\", \"colonnes\")\nrownames(matrice) &lt;- c(\"voilà\", \"des\", \"lignes\")\nattributes(matrice)\n\n$dim\n[1] 3 4\n\n$dimnames\n$dimnames[[1]]\n[1] \"voilà\"  \"des\"    \"lignes\"\n\n$dimnames[[2]]\n[1] \"les\"      \"noms\"     \"de\"       \"colonnes\"\n\n\nOn voit que :\n\nUne matrice n’est rien d’autre qu’un vecteur (ici un vecteur de type \"integer\")\nLes dimensions sont stockées sous la forme d’un attribut dim qui vaut c(nrow, ncol)\nLes noms sont stockés sous la forme d’un attribut dimnames. Une liste de longueur 2 qui vaut list(noms_lignes, noms_colonnes).\nDe manière malheureusmement irrégulière et pour des raisons historiques, les matrices n’ont pas d’attribut class renseigné. La classe est implicite par la présence d’un attribut dim. On pourra par cependant vérifier que inherits(matrice, \"matrix\") vaut TRUE, de même que is.matrix(matrice). Si les matrices étaient reconstruites aujourd’hui, sans doute qu’elles auraient un attribut class comme tout le monde.\n\n\n\n\nOn voit qu’il suffit de renseigner un attribut dim à un vecteur pour définir une matrice. À l’aide de la fonction structure(), définir un vecteur m de valeur 1:12 muni d’un attribut dim qui signale une dimension de 3*4. Vérifier avec inherits(m, \"matrix\") et is.matrix(m) que le vecteur est bien pleinement reconnu comme une matrice.\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nm &lt;- structure(1:12, dim = c(3, 4))\ninherits(m, \"matrix\")\n\n[1] TRUE\n\nis.matrix(m)\n\n[1] TRUE\n\n\nOn a vérifié qu’il suffit de définir un attribut de dimension pour dire qu’un vecteur est une matrice. Une matrice n’est rien de plus qu’un vecteur auquel on a rajouté une dimension.\n\n\n\n\n\nExercice 2 : Simuler des instances\nDans le chapitre sur l’évaluation, on était parvenu à ce compteur :\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    this &lt;-\n      list(\n        suivant = function() {\n          n &lt;&lt;- n + 1L\n          this\n        },\n        get = function() {\n          n\n        }\n      )\n    this\n  }\n\ncompteur_1 &lt;- nouveau_compteur()\ncompteur_2 &lt;- nouveau_compteur()\ncompteur_1$\n  suivant()$\n  suivant()$\n  suivant()\ncompteur_1$get()\ncompteur_2$get()\ncompteur_1$suivant()\ncompteur_2$suivant()\ncompteur_1$get()\ncompteur_2$get()\n\nOn demande dans cette exercice de :\n\nModifier le code de la fonction nouveau_compteur() pour que la liste qu’elle renvoie soit de classe “super_compteur”.\nImplémenter une méthode de la fonction générique print() qui affiche Super Compteur : [i]\\n si le compteur en est à [i] (on rappelle que \\n est une manière d’indiquer un saut de ligne).\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    this &lt;-\n      list(\n        suivant = function() {\n          n &lt;&lt;- n + 1L\n          this\n        },\n        get = function() {\n          n\n        }\n      )\n    class(this) &lt;- \"super_compteur\"\n    this\n  }\n\nprint.super_compteur &lt;- function(x, ...) {\n  cat(\"Super Compteur : \", x$get(), \"\\n\", sep = \"\")\n}\n\ncompteur_1 &lt;- nouveau_compteur()\ncompteur_2 &lt;- nouveau_compteur()\ncompteur_1$\n  suivant()$\n  suivant()$\n  suivant()\n\nSuper Compteur : 3\n\ncompteur_1$get()\n\n[1] 3\n\ncompteur_2$get()\n\n[1] 0\n\ncompteur_1$suivant()\n\nSuper Compteur : 4\n\ncompteur_2$suivant()\n\nSuper Compteur : 1\n\ncompteur_1$get()\n\n[1] 4\n\ncompteur_2$get()\n\n[1] 1\n\n\nOn a maintenant un objet S3 qui se comporte avec des instances, comme en Programmation Orientée Objet classique.",
    "crumbs": [
      "Programmation fonctionnelle objet en R (S3)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html",
    "href": "fonctions_ordre_superieur_2.html",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "",
    "text": "On l’a vu dans la partie précédente, la notion de fonction d’ordre supérieur désigne une fonction avec au moins l’une des propriétés suivantes :\n\nElle a pour argument une ou des fonctions.\nElles retournent a minima une fonction.\n\nDans cette deuxième partie sur les fonctions d’ordre supérieur, nous abordons la thématique des fonctions avec ayant pour retour des fonctions.\nCelles-ci posent un problème vis-à-vis de l’évaluation de leurs symboles internes (aussi appelés noms). Que se passe-t-il par exemple quand j’exécute ce code R ? On y appelle une fonction qui renvoie elle-même une fonction. Il y a plein de choses qui s’appellent x ! Comment cela peut bien se résoudre ?\n\n\n\n\n\n\nOn se rend compte en observant les résultats de quatre choses :\n\nAucune des assignations (&lt;-) internes aux fonctions n’a modifié l’environnement global ; le x global vaut toujours 1L.\nLe arg de la fonction mystère semble avoir été passé à la fonction anonyme.\nLe résultat du x retourné par fun_1() est celui défini à l’intérieur de la fonction anonyme, à savoir 3L.\nLe résultat du x retourné par fun_2() est celui défini à l’intérieur de la fonction anonyme, à savoir 4L.\n\nPourquoi donc ?\n\nDans R, les objets sont contenus dans des environnements. Les environnements sont plus ou moins des petites bulles :\n\nLes environnements sont isolés en écriture selon l’assignation standard &lt;-. Ici il faut bien comprendre que plusieurs objets x existent en même temps dans des environnements différents.\nà l’exception de l’emptyenv, tous les environnements ont un environnement parent. La structure des environnements forme donc un arbre.\nChaque appel de fonction définit un environnement, et non chaque définition. À chaque fois qu’on appelle une fonction, on crée un nouvel environnement. Ici on crée donc deux environnements différents pour mystere.\nLorsque l’on cherche à évaluer un symbole recherche un objet dans un environnement et qu’il n’y existe pas, on va chercher ce symbole dans l’environnement parent (puis à nouveau l’environnement parent si on ne trouve toujours pas et ainsi de suite). Ici, par exemple, fun_1 n’a pas connaissance de arg. Alors on cherche dans l’environnement au dessus. Surprise ! On y trouve arg et l’on peut donc utiliser cette valeur. C’est ce qui explique que fun_1() et fun_2() peuvent renvoyer des résultats différents.\n\nDans la suite, on s’attardera surtout sur la partie bleue du graphique ci-dessus. La partie orange a été abordée à titre d’information, mais n’est pas vraiment le sujet de cette formation. De notre point de vue, l’environnement le plus bas est donc le globalenv.\n\n\n\n\n\n\nNote\n\n\n\nR se charge automatiquement de supprimer les environnements relatifs à fun_1 et fun_2 si on supprime fun_1 et fun_2. Il dispose pour cela de ce qu’on appelle un ramasse-miettes.",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#les-environnements",
    "href": "fonctions_ordre_superieur_2.html#les-environnements",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "",
    "text": "On l’a vu dans la partie précédente, la notion de fonction d’ordre supérieur désigne une fonction avec au moins l’une des propriétés suivantes :\n\nElle a pour argument une ou des fonctions.\nElles retournent a minima une fonction.\n\nDans cette deuxième partie sur les fonctions d’ordre supérieur, nous abordons la thématique des fonctions avec ayant pour retour des fonctions.\nCelles-ci posent un problème vis-à-vis de l’évaluation de leurs symboles internes (aussi appelés noms). Que se passe-t-il par exemple quand j’exécute ce code R ? On y appelle une fonction qui renvoie elle-même une fonction. Il y a plein de choses qui s’appellent x ! Comment cela peut bien se résoudre ?\n\n\n\n\n\n\nOn se rend compte en observant les résultats de quatre choses :\n\nAucune des assignations (&lt;-) internes aux fonctions n’a modifié l’environnement global ; le x global vaut toujours 1L.\nLe arg de la fonction mystère semble avoir été passé à la fonction anonyme.\nLe résultat du x retourné par fun_1() est celui défini à l’intérieur de la fonction anonyme, à savoir 3L.\nLe résultat du x retourné par fun_2() est celui défini à l’intérieur de la fonction anonyme, à savoir 4L.\n\nPourquoi donc ?\n\nDans R, les objets sont contenus dans des environnements. Les environnements sont plus ou moins des petites bulles :\n\nLes environnements sont isolés en écriture selon l’assignation standard &lt;-. Ici il faut bien comprendre que plusieurs objets x existent en même temps dans des environnements différents.\nà l’exception de l’emptyenv, tous les environnements ont un environnement parent. La structure des environnements forme donc un arbre.\nChaque appel de fonction définit un environnement, et non chaque définition. À chaque fois qu’on appelle une fonction, on crée un nouvel environnement. Ici on crée donc deux environnements différents pour mystere.\nLorsque l’on cherche à évaluer un symbole recherche un objet dans un environnement et qu’il n’y existe pas, on va chercher ce symbole dans l’environnement parent (puis à nouveau l’environnement parent si on ne trouve toujours pas et ainsi de suite). Ici, par exemple, fun_1 n’a pas connaissance de arg. Alors on cherche dans l’environnement au dessus. Surprise ! On y trouve arg et l’on peut donc utiliser cette valeur. C’est ce qui explique que fun_1() et fun_2() peuvent renvoyer des résultats différents.\n\nDans la suite, on s’attardera surtout sur la partie bleue du graphique ci-dessus. La partie orange a été abordée à titre d’information, mais n’est pas vraiment le sujet de cette formation. De notre point de vue, l’environnement le plus bas est donc le globalenv.\n\n\n\n\n\n\nNote\n\n\n\nR se charge automatiquement de supprimer les environnements relatifs à fun_1 et fun_2 si on supprime fun_1 et fun_2. Il dispose pour cela de ce qu’on appelle un ramasse-miettes.",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#lassignation-remontante--",
    "href": "fonctions_ordre_superieur_2.html#lassignation-remontante--",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "L’assignation remontante (<<-)",
    "text": "L’assignation remontante (&lt;&lt;-)\nOn remplace les deux assignations intra-fonctionnelles par un nouvel opérateur, l’assignation remontante &lt;&lt;-.\n\n\n\n\n\n\nOn observe que le x global est cette fois-ci modifié par l’assignation remontante. En effet, cet opérateur remonte les différents environnements parents jusqu’à trouver un x déjà existant et le modifie.\nIci, à chaque affectation, on remonte donc jusqu’à l’environnement global et on trouve x. On modifie alors celui-ci.\n\nÀ la fin de l’exécution, on a donc le schéma ci-dessus. On n’a pas créé de version locale de x.\n\n\n\n\n\n\nNe pas assigner le global\n\n\n\nAttention cependant, quand bien même l’opérateur &lt;&lt;- peut créer des fonctions manipulant l’environnement global comme on vient de le voir, ce n’est pas une bonne pratique. L’utilisation de &lt;&lt;- doit être fait de manière circonscrite à des cas que l’on va aborder dans la suite de cette page. Modifier l’environnement global est le plus souvent une (très) mauvaise pratique. En effet, cela rompt complètement le paradigme fonctionnel dès lors que l’on a des états globaux pouvant mener à des interdépendances, des problèmes d’isolation…\n\n\n\n\n\n\n\n\nNote\n\n\n\nPar défaut, si la remontée des environnements ne donne rien, l’assignation remontante assignera dans l’environnement global.\n\n\nQue se passe-t-il si on n’utilise l’assignation remontante que dans la fonction anonyme et plus pour le x &lt;- 2L de la fonction de second ordre ? Pourquoi ?\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\n\nx &lt;- 1L\nmystere &lt;-\n  function(arg) {\n    x &lt;- 2L\n    function() {\n      x &lt;&lt;- arg\n      return(x)\n    }\n  }\n\nfun_1 &lt;- mystere(3L)\nfun_2 &lt;- mystere(4L)\nx\n\n[1] 1\n\nfun_1()\n\n[1] 3\n\nx\n\n[1] 1\n\nfun_2()\n\n[1] 4\n\nx\n\n[1] 1\n\n\nEn apparence, les fonctions semblent se comporter à nouveau comme si on utilisait l’assignation locale. Mais, en réalité, le comportement par environnements est différent.\n\nÀ la fin de l’exécution on a le graphe ci-dessus. Les x &lt;- 2L des différentes environnements de mystère ont été ecrasés respectivement par les x &lt;&lt;- 3L et x &lt;&lt;- 4L de fun_1 fun_2. Ici, comme on n’utilise de toutes manières pas les valeur 2L, ce n’est pas très grave. On préserve l’isolation entre environnements donc tout va bien ; même si ici la notation est inutile.",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#closures",
    "href": "fonctions_ordre_superieur_2.html#closures",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Closures",
    "text": "Closures\nOn a vu que des fonctions peuvent retourner des fonctions, et qu’il s’agit d’un des deux types de fonctions d’ordre supérieur. Dans R, on appelle aussi ces fonctions des function factories (fabrique de fonctions en français, mais le terme n’est pas très employé). Les fonctions renvoyées par les function factories sont appelées closures (fermetures en français, mais le terme n’est pas très employé non-plus).\nLe nom de closure illustre un aspect de ces fonctions d’ordre supérieur. On a vu qu’il est possible d’écrire dans les environnements parents qui apparaissent comme isolés les uns des autres. Et bien utilisons cette propriété !\n\n\n\n\n\n\nMais que se passe-t-il ? C’est très étonnant ! Il semble que l’on ait défini des états ; et pourtant il n’y a aucune variable n dans l’environnement global !\n\nEn fait, on appelle ces fonctions des closures parce que les closures “enferment” leur environnement parent. Elles le préservent également du ramasse-miette puisque le ramasse-miette ne va jamais supprimer un environnement qui est encore désigné quelque part. Elle permettent de maintenir un espace isolé où l’on peut tout-à-fait faire des modifications qui persistent dans le temps.\nSeul l’appel à la fabrique permet de créer un nouvel environnement. Ici, c’est nouveau_compteur() qui crée un nouveau compteur. On appelle un tel espace instance.\n\n\n\n\n\n\nWarning\n\n\n\nIl est important de noter que compteur_1bis réfère exactement au même compteur que compteur_1, car il désigne le même environnement. C’est précisément le principe d’une instance.\n\n\nCette astuce est puissante et permet de maintenir des états à l’intérieur d’un langage fonctionnel. Cela rompt l’approche maximaliste d’un langage fonctionnel idéal qui ne contiendrait que des fonctions complètement pures, mais cela la rompt de manière maitrisée, la plus locale possible. On ne doit bien sûr user de cette astuce qu’avec parcimonie, quand cela semble nécessaire.",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#closures-complexes",
    "href": "fonctions_ordre_superieur_2.html#closures-complexes",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Closures complexes",
    "text": "Closures complexes\nUne closure peut renvoyer plusieurs fonctions différentes par exemple dans une liste. On s’approche alors beaucoup de la définition d’un objet en Programmation Orientée Objet.\n\n\n\n\n\n\nIci, les deux appels de nouvelle_resolution() permettent de définir deux environnement différents. Dans chacun de ces environnements, les fonctions setX(), setY(), getX() et getY() agiront de manière isolée, comme on le voit dans le schéma ci-dessous.",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#quizz",
    "href": "fonctions_ordre_superieur_2.html#quizz",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Quizz",
    "text": "Quizz\n\nQuestion 1\n\nC’est lors de la définition de la fonction que l’on détermine son environnement.\n\n\n\n\n ✗Vrai\n\n\n ✓Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nC’est lors de l’appel d’une fonction que l’on détermine un environnement. La nuance est importante car une même fonction appelée plusieurs fois définit plusieurs environnements différents.\n\n\n\n\n\nQuestion 2\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;-\n  function(val) {\n    x &lt;- val\n    return(x)\n  }\nfonction(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✗Vrai\n\n\n ✓Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nNon, l’assignation simple affecte des valeurs dans l’environnement créé lors de l’appel d’une fonction et il n’y a strictement aucun danger de conflit.\n\n\n\n\n\nQuestion 3\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;-\n  function(val) {\n    x &lt;&lt;- val\n    return(x)\n  }\nfonction(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✓Vrai\n\n\n ✗Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nVrai, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, elle va donc modifier le x de l’environnement global.\n\n\n\n\n\nQuestion 4\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;-\n  function(val) {\n    x &lt;- 0\n    x &lt;&lt;- val\n    return(x)\n  }\nfonction(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✓Vrai\n\n\n ✗Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nVrai, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, elle va donc modifier le x de l’environnement global en ignorant celui qui est directement dans l’environnement local.\n\n\n\n\n\nQuestion 5\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;- function() {\n  x &lt;- 0\n  function(val) {\n    x &lt;&lt;- val\n    return(x)\n  }\n}\n\nfonction()(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✗Vrai\n\n\n ✓Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nFaux, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, le premier environnement parent est celui instancié par fonction. Et il s’avère qu’il contient un objet de nom x. Donc le x de l’environnement global n’est pas écrasé.\n\n\n\n\n\nQuestion 6\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;- function() {\n  function(val) {\n    x &lt;&lt;- val\n    return(x)\n  }\n}\n\nfonction()(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✓Vrai\n\n\n ✗Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nVrai, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, le premier environnement parent est celui instancié par fonction. Mais il ne contient aucun objet de nom x. On remonte donc encore les environnements jusqu’à l’environnement global, et donc le x global est modifié.\n\n\n\n\n\nQuestion 7\n\nDans le code ci-dessous :\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    function() {\n      n &lt;&lt;- n + 1L\n      return(n)\n    }\n  }\n\ncompteur_a &lt;- nouveau_compteur()\ncompteur_b &lt;- compteur_a\ncompteur_a()\ncompteur_a()\ncompteur_b()\n\nCombien va afficher le résultat de compteur_b() ?\n\n\n\n\n ✗0\n\n\n ✗1\n\n\n ✗2\n\n\n ✓3\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nLa réponse vaut 3. Un compteur a été instancié dans compteur_a par nouveau_compteur(), puis il a été recopié dans compteur_b, mais n’a pas été réinstancié. On désigne donc le même compteur.\n\n\n\n\n\nQuestion 8\n\nDans le code ci-dessous :\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    function() {\n      n &lt;&lt;- n + 1L\n      return(n)\n    }\n  }\n\ncompteur_a &lt;- nouveau_compteur()\ncompteur_b &lt;- nouveau_compteur()\ncompteur_a()\ncompteur_a()\ncompteur_b()\n\nCombien va afficher le résultat de compteur_b() ?\n\n\n\n\n ✗0\n\n\n ✓1\n\n\n ✗2\n\n\n ✗3\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nLa réponse vaut 1. Deux compteurs différents ont été instanciés dans compteur_a et compteur_b.",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#exercice",
    "href": "fonctions_ordre_superieur_2.html#exercice",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Exercice",
    "text": "Exercice\nSupposons que l’on ait une fonction qui mette longtemps à répondre, par exemple :\n\ncalcul_de_dingue &lt;- function(arg) {\n  Sys.sleep(3L) # Une attente de 3 secondes pour simuler un long calcul.\n  return(2 * arg)\n}\n\nOù arg est un vecteur numérique.\nOn souhaite utiliser une closure pour définir une fonction calcul_moins_dingue. calcul_moins_dingue renvoie les mêmes valeurs que calcul_de_dingue pour les mêmes entrées mais stocke ses résultats pour éviter de relancer les calculs plus d’une fois.\nL’idée est que calcul_moins_dingue doit :\n\nappeler calcul_de_dingue si elle n’a pas été déjà appelée avec une certaine valeur, et stocker le résultat dans une liste.\nTout appel subséquent de calcul_moins_dingue avec une valeur déjà appelée doit restituer le résultat stocké plutôt que de réappeler calcul_de_dingue.\n\nOn appelle ce principe un cache ; l’axiome sous-jacent est que calcul_de_dingue est une fonction pure (on peut complètement prévoir son résultat à partir de ses arguments). On pourra utiliser la fonction identical(x, y) qui permet de vérifier que deux objets sont exactement identiques (identical(1,1L) est faux).\n\n\n\n\n\n\n\n\n\n\n\n\nAide (l’exercice est compliqué, ne pas hésiter à consulter)\n\n\n\n\n\n\ncalcul_de_dingue &lt;- function(arg) {\n  Sys.sleep(3L) # Une attente de 3 secondes pour simuler un long calcul.\n  return(2 * arg)\n}\n\ncalcul_de_dingue_cache &lt;- function(taille_cache = 10L) {\n  cache &lt;- vector(\"list\",taille_cache)\n  cache_suivant &lt;- 1L\n  function(arg) {\n    index_en_cache &lt;- which(vapply(cache, \\(x) identical(x$arg,arg), TRUE))[1L]\n    # Cette ligne précédente peut être remplacée par\n    # index_en_cache &lt;- Position(\\(x) identical(x$arg,arg), cache)\n    # Qui fait la même chose (mais on n'a pas vu Position)\n    if (is.na(index_en_cache)) {\n      # Remplir ici\n      # C'est le cas où l'on ne retrouve pas la bonne entrée dans la cache.\n    }\n    else {\n      # Remplir ici \n      # C'est le cas où index_en_cache contient le numéro de cache et donc on\n      # n'a pas à refaire le calcul.\n    }\n  }\n}\n\ncalcul_moins_dingue &lt;- calcul_de_dingue_cache()\ncalcul_moins_dingue(c(1, 3))\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\ncalcul_moins_dingue(c(4, 7))\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\ncalcul_de_dingue &lt;- function(arg) {\n  Sys.sleep(3L) # Une attente de 3 secondes pour simuler un long calcul.\n  return(2 * arg)\n}\n\ncalcul_de_dingue_cache &lt;- function(taille_cache = 10L) {\n  cache &lt;- vector(\"list\",taille_cache)\n  cache_suivant &lt;- 1L\n  function(arg) {\n    index_en_cache &lt;- which(vapply(cache, \\(x) identical(x$arg,arg), TRUE))[1L]\n    # Cette ligne précédente peut être remplacée par\n    # index_en_cache &lt;- Position(\\(x) identical(x$arg,arg), cache)\n    # Qui fait la même chose (mais on n'a pas vu Position)\n    if (is.na(index_en_cache)) {\n      valeur &lt;- calcul_de_dingue(arg)\n      cache[[cache_suivant]] &lt;&lt;- list(arg = arg,\n                                      valeur = valeur)\n      cache_suivant &lt;&lt;- cache_suivant %% taille_cache + 1L\n      valeur\n    }\n    else cache[[index_en_cache]]$valeur\n  }\n}\n\ncalcul_moins_dingue &lt;- calcul_de_dingue_cache()\ncalcul_moins_dingue(c(1, 3))\n\n[1] 2 6\n\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\n\n[1] 2 6\n\ncalcul_moins_dingue(c(4, 7))\n\n[1]  8 14\n\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\n\n[1]  8 14\n\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\n\n[1] 2 6\n\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\n\n[1]  8 14",
    "crumbs": [
      "Fonctions d'ordre supérieur (retours)"
    ]
  },
  {
    "objectID": "evaluation.html",
    "href": "evaluation.html",
    "title": "Évaluation des fonctions en R",
    "section": "",
    "text": "R repose (comme beaucoup de langages fonctionnels) sur des expressions. Une expression est comme une phrase en français mais en R. Une expression est simplement un ensemble non-évalué de code R syntaxiquement correct, même si ce sens peut être farfelu ou produire une erreur à l’évaluation dans un environnement (voire dans n’importe quel environnement).\n\n1 + 2\nfunction(x) sin(2*x)\nround(exp(3) + 1, 5)\narnaud &lt;- (bonjour + \"voiture\") ^ sqrt(2 + \"train\")\n1 &lt;- 2\n\nTout ce qui est au dessus est une expression avant d’être évalué, possiblement par une erreur. A contrario, les lignes ci-dessous ne peuvent pas correspondre à une expression. Elles sont syntaxiquement incorrectes.\n2 *\nexp(\n&lt;- 3\nPour ne pas évaluer du code R syntaxiquement correct et le laisser sous forme d’expression, on peut utiliser quote().\n\n\n\n\n\n\nLe code syntaxiquement incorrect ne peut lui pas former une expression :",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#expression",
    "href": "evaluation.html#expression",
    "title": "Évaluation des fonctions en R",
    "section": "",
    "text": "R repose (comme beaucoup de langages fonctionnels) sur des expressions. Une expression est comme une phrase en français mais en R. Une expression est simplement un ensemble non-évalué de code R syntaxiquement correct, même si ce sens peut être farfelu ou produire une erreur à l’évaluation dans un environnement (voire dans n’importe quel environnement).\n\n1 + 2\nfunction(x) sin(2*x)\nround(exp(3) + 1, 5)\narnaud &lt;- (bonjour + \"voiture\") ^ sqrt(2 + \"train\")\n1 &lt;- 2\n\nTout ce qui est au dessus est une expression avant d’être évalué, possiblement par une erreur. A contrario, les lignes ci-dessous ne peuvent pas correspondre à une expression. Elles sont syntaxiquement incorrectes.\n2 *\nexp(\n&lt;- 3\nPour ne pas évaluer du code R syntaxiquement correct et le laisser sous forme d’expression, on peut utiliser quote().\n\n\n\n\n\n\nLe code syntaxiquement incorrect ne peut lui pas former une expression :",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#évaluation-à-temps-dexécution",
    "href": "evaluation.html#évaluation-à-temps-dexécution",
    "title": "Évaluation des fonctions en R",
    "section": "Évaluation à temps d’exécution",
    "text": "Évaluation à temps d’exécution\nLe code n’est interprêté qu’à son temps d’exécution. Contrairement à des langages plus formels qui donnent une importance plus grande au temps de “définition” ou “compilation”. R attend le dernier moment pour vérifier si quelque chose a un sens.\n\n\n\n\n\n\nDans la petite bidouille ci-dessus, il serait bien difficile à un compilateur de prévoir que l’objet machin existe au moment de l’appel à machin. De même, dans certains langages de programmation, l’expression arnaud &lt;- (bonjour + \"voiture\") ^ sqrt(2 + \"train\") pourrait être refusée dès qu’on la propose.\nMais R ne bronche pas. R n’essaye pas de donner un sens au corps des fonctions à l’avance. Dès lors que la syntaxe est correcte, ça lui suffit et on verra plus tard !",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#évaluation-paresseuse-et-court-circuit",
    "href": "evaluation.html#évaluation-paresseuse-et-court-circuit",
    "title": "Évaluation des fonctions en R",
    "section": "Évaluation paresseuse et court-circuit",
    "text": "Évaluation paresseuse et court-circuit\nR est fainéant. Il n’évaluera les arguments d’une fonction qu’au dernier moment s’il en a besoin (évaluation paresseuse des arguments). Les expressions employant des contrôle (if, else…) définissent elles aussi une forme de paresse dans la mesure où leurs sous-parties non-retenues ne sont pas évaluées (évaluation paresseuse des structures de contrôle). À l’intérieur même des expressions, les expressions faites d’opérateurs logiques unitaires (&& et || mais pas & ni | qui sont vectoriels) évaluent elles aussi le moins possible de leurs sous-parties (court-circuit).\n\n\n\n\n\n\nRemarque\n\n\n\nDans le monde de R, quand on parle d’évaluation paresseuse, on se réfère surtout à l’évaluation paresseuse des arguments. Mais l’évaluation paresseuse est un concept assez général. L’idée de base est de n’évaluer que ce dont on a absolument besoin et pile au moment où on en a besoin.\n\n\n\n\n\n\n\n\nDans l’exemple précédent, si les arguments n’étaient pas évalués de manière paresseuse, autant l’évaluation de x que celle de y précipiterait une erreur :\n\ncelle de x car stop() est la fonction de R permettant de stopper l’exécution et de retourner une erreur avec le message fourni.\ncelle de y car une matrice avec un nombre de lignes négatifs, ça n’existe pas.\n\nMais le corps de la fonction lazy_eval étant réduit à son plus simple appareil, à savoir simplement TRUE, il ne requiert pas d’en évaluer les arguments. Il n’y a donc aucune erreur d’exécution et la fonction retourne bien TRUE !\n\n\n\n\n\n\nDans l’exemple ci-dessus, on illustre le bon fonctionnement paresseux d’une structure de contrôle. La partie else n’est évaluée que si choix est FALSE.\n\n\n\n\n\n\nL’exemple ci-dessus repose à la fois sur la paresse des structures de contrôle et sur celle des arguments. L’argument x n’est évalué que dans le cas où choix vaut FALSE.\n\n\n\n\n\n\nWarning\n\n\n\n\nlazy_eval_1 &lt;-\n  function(x = stop(\"C'est une erreur !\"),\n           y = matrix(1:9, nrow = -3L)) {\n    truc &lt;- x\n    TRUE\n  }\nlazy_eval_2 &lt;-\n  function(x = stop(\"C'est une erreur !\"),\n           y = matrix(1:9, nrow = -3L)) {\n    x\n    TRUE\n  }\n# Essayer lazy_eval_1() et lazy_eval_2()\n\n\nL’assignation truc &lt;- x force l’évaluation de x.\nUne ligne avec simplement écrit x force l’évaluation de x.\n\nC’est pourquoi les deux appels de fonction ci-dessus précipitent une erreur.\n\n\n\n\n\n\n\n\nOn voit ci-dessus que :\n\nDans le cas de cas de court_circuit_1, le stop() n’est pas évalué si choix vaut FALSE. En effet, peu importe la valeur du deuxième terme, on peut bien deviner que si le premier est faux, la valeur du && doit être FALSE. Pas besoin donc de continuer.\nDans le cas de cas de court_circuit_2, le stop() n’est pas évalué si choix vaut TRUE. En effet, peu importe la valeur du deuxième terme, on peut bien deviner que si le premier est vrai, la valeur du || doit être TRUE. Pas besoin donc de continuer.\n\n\n\n\n\n\n\nWarning\n\n\n\n\n\n\n\n\n\nAttention, les opérateurs logiques & et |, qui sont normalement prévus pour de la logique vectorielle, ne sont pas court-circuités comme on peut le voir dans l’exemple précédent.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#évaluation-standard",
    "href": "evaluation.html#évaluation-standard",
    "title": "Évaluation des fonctions en R",
    "section": "Évaluation standard",
    "text": "Évaluation standard\nOn a vu dans le classeur précédent que les appels de fonctions définissent de nouveaux environnements, et que les différents symboles (noms d’objet) utilisés sont évalués en remontant l’arbre des environnements jusqu’à trouver le bon symbole.\nOn vient également de voir que les expressions sont évaluées au dernier moment, ce que l’on appelle l’évaluation paresseuse. Les expressions sont évaluées dans leur environnement, par exemple celui de leur fonction.\nLa somme de ces deux propriétés définit l’évaluation standard en R.\nR permet cependant des bâtir des exceptions à cette “évaluation standard”. On appelle ces évaluations irrégulières des… Évaluations non-standard (Non-Standard Evaluation, NSE).\n\n\n\n\n\n\nLorsque l’on charge un package, par exemple disaggR, on utilise library() avec à l’intérieur un symbole qui n’existe pourtant pas dans l’environnement global. Ici l’environnement global ne contient pas d’objet disaggR. C’est une forme d’évaluation non-standard puisque library ne réagit pas comme toutes les fonctions de R. Mais bon, ce n’est pas une évaluation non-standard des plus utiles en soi.\nLa plus utilisée de ces NSE est la tidyeval régnant dans le tidyverse.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-les-bases",
    "href": "evaluation.html#tidyeval-les-bases",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : les bases",
    "text": "tidyeval : les bases\n\n\n\n\n\n\nLorsque l’on exécute le code précédent, on peut se rendre compte que celui-ci n’est pas exécuté par évaluation standard : en effet, le symbole height comme le symbole name n’existent pas dans l’environnement global. Ils ne remontent pas les environnements. Ils sont évalués dans le contexte du premier argument, en l’occurence dplyr::starwars pour ce qui est de l’appel à filter(), puis filter(dplyr::starwars, height &gt; 200) en ce qui concerne l’appel à select().\ndplyr évite une syntaxe verbieuse et peu lisible. Pour écrire quelque chose de rigoureusement équivalent dans base, on aurait dû écrire le code ci-dessous (on a rajouté ! is.na() car filter() enlève les NA par défaut, et drop = FALSE car sinon R convertit les data.frame d’une seule unique colonne en vecteur).\n\n\n\n\n\n\nLa tidyeval aide à cette syntaxe plus légère. En effet, dans dplyr, on n’a pas à répéter systématiquement qu’on se trouve dans le tibble starwars. C’est implicite ! Les arguments de filter() et select() sont tous deux évalués dans le contexte de starwars.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-comportement-des-expressions-et-des-quosures",
    "href": "evaluation.html#tidyeval-comportement-des-expressions-et-des-quosures",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : comportement des expressions et des quosures",
    "text": "tidyeval : comportement des expressions et des quosures\nLorsque l’on donne pour argument height &gt; 200 à dplyr, cela ressemble à ce que l’on a vu plus haut, une expression. En réalité, le tidyverse utilise des quosures, une notion similaire aux expressions mais au comportement différent.\n\n\n\n\n\n\nOn voit ici que l’évaluation de x * height n’est pas interprétée de la même manière selon que l’on définisse une quosure ou une expression. On note deux choses :\n\nheight est évalué de la même manière dans les deux cas. Elles cherchent tout d’abord dans la donnée qui leur est spécifiée, à savoir dplyr::starwars. Dans la mesure où le symbole height existe dans ces données, aucune n’a besoin d’aller voir ailleurs.\nPar contre, l’évaluation de x est différente. Dans le cas de l’expression, puisque le symbole n’existe pas dans dplyr::starwars, l’évaluation standard va dérouler les environnements à partir de l’environnement d’appel du eval. Ici on trouve directement une valeur, le 1. Et hop ! À contrario, la quosure va dérouler les environnements à partir de l’environnement de création de la quosure. C’est pour cela que x vaut 2.\n\n\n\n\n\n\n\nImportant : Ce n’est pas une distinction futile !\n\n\n\nCela peut sembler futile, mais cette particularité rend l’utilisation de quosure beaucoup plus sécurisée et moins surprenante à l’utilisateur. L’utilisateur n’est pas censé connaitre le code interne des fonctions qu’il utilise (filter, etc.). Si celles-ci évaluaient bêtement les expressions, imaginons que leur code interne contienne une variable x, et que l’utilisateur évalue une expression avec un x, il y aurait conflit quand bien même celui-ci aurait défini un x dans l’environnement global. Ce n’est vraisemblablement pas ce que l’utilisateur attend.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-sous-le-chapeau-des-quosures",
    "href": "evaluation.html#tidyeval-sous-le-chapeau-des-quosures",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : sous le chapeau des quosures",
    "text": "tidyeval : sous le chapeau des quosures\nLorsque l’on définit une quosure, on ne définit en fait rien de plus qu’un couple entre une expression et l’environnement d’appel.\n\n\n\n\n\n\nSi j’affiche en effet le contenu de ma_quosure, je vois que celle-ci contient deux éléments :\n\nL’expression x * height\nUn lien vers l’environnement global\n\nC’est cet environnement global qui permet, lors de la tidyeval, de remonter au bon environnement.\nUn comportement tout-à-fait équivalent à celui des quosures est possible avec des expressions, mais il faut alors spécifier une expression et un environnement.\n\n\n\n\n\n\nOn a rajouté ci-dessus à eval() un argument enclos qui spécifie le lieu où les symboles qui ne sont pas trouvés dans les données de envir vont être évaluées. Grâce à cela, l’évaluation de x se fait par rapport à la variable de l’environnement global dans les deux cas !\nLa quosure n’est autre qu’une expression complétée par un environnement de closure, d’où son nom.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-évaluation-avec-le-bang",
    "href": "evaluation.html#tidyeval-évaluation-avec-le-bang",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : évaluation avec le bang (!!) !",
    "text": "tidyeval : évaluation avec le bang (!!) !\nOn a donc vu les :\n\nsymboles (également appelés noms), les mots désignant des objets à évaluer dans des environnements.\nquosures, un couple entre expression et environnement d’appel.\n\nL’usage intensif de ces éléments est une caractéristique particulière de la programmation dans le tidyverse, particulièrement dans dplyr.\n\n\n\n\n\n\nDans l’exemple ci-dessus, on a programmé avec dplyr ! On a fait une fonction à qui on peut suggérer un filtre et un nom de colonne (sous la forme d’un symbole), et ces éléments vont être évalués dans le contexte des données de tbl.\nComment est-ce que cela fonctionne ? L’idée de base est que enquo() et ensym() empêchent l’évaluation (sous la forme d’une quosure et d’un symbole, respectivement), tandis que les bang !! vont au contraire demander évalue-moi cela ici.\nPlus spécifiquement, avec le couple arg &lt;- enquo(arg) / !!, on va :\n\nÉviter l’évaluation d’un argument et le transformer en objet de type quosure s’il n’est pas déjà une quosure, en enfermant l’environnement parent.\nS’il est déjà une quosure, il va passer la quosure telle quelle, en conservant l’environnement déjà enfermé dedans.\n\nDe cette manière, d’appel de fonction en appel de fonction, on transmet l’environnement dans lequel la quosure a été effectivement saisie (ici height &gt; x) .\nIci, il n’y a qu’un unique appel de fonction. L’environnement contenu dans la quosure transmise à filter n’est autre que l’environnement global dans lequel le x peut s’évaluer.\nL’effet du couple arg &lt;- ensym(arg) / !! est plus simple puisque les symboles n’enferment pas de lien à un environnement :\n\nOn évite l’évaluation du symbole avec ensym()\nOn dit de l’évaluer avec !! dans une nouvelle fonction (qui à son tour peut en fait stopper l’évaluation avec un nouveau ensym() et la passer à nouveau plus bas avec !!)\n\n\n\n\n\n\n\nOn voit ci-dessus que l’on peut même utiliser les bang !! avant le = dans une fonction qui utilise des = comme summarise. Mais il faut alors modifier le = par un := pour que ça marche.\n\n\n\n\n\n\nTip\n\n\n\nIl existe un raccourci pour enquo() et !! qui allège un peu, mais est sans doute un peu moins clair et ne permet pas de faire une distinction entre symboles et quosures. On aurait pu écrire :\n\n\n\n\n\n\nCela à l’avantage d’être plus succinct ; cela a le désavantage d’être moins explicite. C’est au choix.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-dots-et-bang-bang",
    "href": "evaluation.html#tidyeval-dots-et-bang-bang",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : dots et bang bang (!!!) !",
    "text": "tidyeval : dots et bang bang (!!!) !\nParfois, on a besoin non pas d’un seul argument symbole/quosure mais d’un nombre indéfini. Des variantes de enquo() et ensym() existent au pluriel. Ces variantes sont enquos() et ensyms() et s’utilisent avec l’opérateur !!!.\n\n\n\n\n\n\nTout d’abord, l’exemple ci-dessus reprend le filtre_et_select mais en acceptant plusieurs sélections dans les dots, car on a utilisé ensyms(). On a donc de manière conjointe utilisé !!!.\n\n\n\n\n\n\nInversement, dans ce dernier exemple, on a laissé la possibilité de spécifier plusieurs filtres en utilisant enquos() et en les faisant évaluer par !!! dans le filter().\n\n\n\n\n\n\nTip\n\n\n\nLes !!! passent aussi les noms d’arguments dans les ..., donc sont aussi solubles avec les fonctions de type rename ou summarise.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#exercices",
    "href": "evaluation.html#exercices",
    "title": "Évaluation des fonctions en R",
    "section": "Exercices",
    "text": "Exercices\n\nExercice 1\nÉcrire une fonction filtre_et_summarise de la forme function(tbl, filtre, ...) et qui :\n\napplique le filtre fourni sur le tibble.\npuis passe à summarise les éléments du ....\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice 2\nOn souhaite écrire une fonction faire_taux(tbl, ...) qui prend dans les ... des conditions booléennes et retourne des taux avec les mêmes noms que ceux des arguments fournis.\nPar exemple, dans :\n\ntbl %&gt;%\n  faire_taux(hello = moyen == \"voiture\" & prenom == \"arnaud\",\n             super = bonjour & moyen == \"voiture\",\n             bonjour = bonjour)\n\ndoit retourner :\n\n\n# A tibble: 1 × 3\n  hello super bonjour\n  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1   0.5     0    0.25\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAide 1 (optionnel)\n\n\n\n\n\nOn pourra s’aider d’une première étape de pipe avec transmute. transmute ressemble à mutate mais abandonne toutes les colonnes non-transformées.\n\n\n\n\n\n\n\n\n\nAide 2 (optionnel mais à ne pas consulter avant minimum 15 minutes de brainstorming !)\n\n\n\n\n\nPenser à across() qui permet d’appliquer, dans un mutate(), un transmute() ou un summarise(), une fonction à plusieurs colonnes en même temps.\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice 3\nDans la partie précédente, on a vu comment on peut faire un compteur avec des closures.\nOn avait :\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    function() {\n      n &lt;&lt;- n + 1L\n      return(n)\n    }\n  }\n\ncompteur &lt;- nouveau_compteur()\ncompteur()\ncompteur()\ncompteur()\n\nOn veut maintenant modifier ce compteur, de sorte à pouvoir permettre des enchaînements d’incrémentations.\n\ncompteur$\n  suivant()$\n  suivant()$\n  suivant()\n\ndoit incrémenter 3 fois l’état interne, mais ne doit pas en afficher sa valeur.\n\ncompteur$get()\n\ndoit afficher la valeur de l’état interne (donc 3 après 3 incrémentations).\nPour cela, on va, comme on l’a vu au chapiter précédent, utiliser une liste de fonctions. Et on doit aussi utiliser la propriété de R d’évaluation au temps d’exécution. Complétez le modèle suivant de sorte à obtenir les bons résultats.\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    this &lt;-\n      list(\n        suivant = function() {\n          n &lt;&lt;- n + 1L\n          this\n        },\n        get = function() {\n          n\n        }\n      )\n    this\n  }\n\ncompteur_1 &lt;- nouveau_compteur()\ncompteur_2 &lt;- nouveau_compteur()\ncompteur_1$\n  suivant()$\n  suivant()$\n  suivant()\n\n$suivant\nfunction() {\n          n &lt;&lt;- n + 1L\n          this\n        }\n&lt;environment: 0x558c429f0050&gt;\n\n$get\nfunction() {\n          n\n        }\n&lt;environment: 0x558c429f0050&gt;\n\ncompteur_1$get() # doit afficher 3\n\n[1] 3\n\ncompteur_2$get() # doit afficher 0\n\n[1] 0\n\ncompteur_1$suivant()\n\n$suivant\nfunction() {\n          n &lt;&lt;- n + 1L\n          this\n        }\n&lt;environment: 0x558c429f0050&gt;\n\n$get\nfunction() {\n          n\n        }\n&lt;environment: 0x558c429f0050&gt;\n\ncompteur_2$suivant()\n\n$suivant\nfunction() {\n          n &lt;&lt;- n + 1L\n          this\n        }\n&lt;bytecode: 0x558c42ba5cc0&gt;\n&lt;environment: 0x558c42a59180&gt;\n\n$get\nfunction() {\n          n\n        }\n&lt;bytecode: 0x558c42bfef78&gt;\n&lt;environment: 0x558c42a59180&gt;\n\ncompteur_1$get() # doit afficher 4\n\n[1] 4\n\ncompteur_2$get() # doit afficher 1\n\n[1] 1\n\n\nLe code ci-dessus peut sembler étonnant ; this est en quelque-sorte auto-référentiel. Mais :\n\nAu moment où nouveau_compteur() s’exécute, R se moque de savoir si la fonction anonyme sous suivant a un sens.\nAu moment où nouveau_compteur() retourne, this existe dans l’environnement de l’instance considérée.\nsuivant() est ne peut être appelé qu’après le retour de nouveau_compteur() donc this existe bel et bien.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation est une manière de programmer un ordinateur basé sur un ensemble de principes ou une théorie.\n\nUn paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#paradigmes-de-programmation",
    "href": "index.html#paradigmes-de-programmation",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation est une manière de programmer un ordinateur basé sur un ensemble de principes ou une théorie.\n\nUn paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-procédurale",
    "href": "index.html#la-programmation-procédurale",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation procédurale",
    "text": "La programmation procédurale\nLa programmation procédurale est le plus ancien paradigme de programmation. Il s’agit d’une séquence de procédures, c’est-à-dire une série d’étapes à réaliser pour faire quelque chose. On peut voir cela comme une recette de cuisine.\nSupposons que l’on veuille peindre un mur en vert, et que la procédure mélanger_couleurs_sur_palette(palette) mélange les deux premières couleurs de la palette pour stocker le résulat de ce mélange au troisième emplacement de la palette, on pourrait faire :\n\nmettre_sur_palette(palette, bleu)\nmettre_sur_palette(palette, jaune)\nmélanger_couleurs_sur_palette(palette)\npeindre_mur(mur, palette[3])\n\nIl faut bien mesurer ce qui se passe à la fin de la dernière ligne : on a sélectionné la couleur de la palette en appelant son emplacement numéro 3 avec palette[3]. Cela suppose d’une part que l’on connait le fonctionnement interne des palettes, et d’autre part que cette structure interne ne change jamais. Si l’on change le code interne de la palette, il faudra aussi changer notre code. Notre programme dépend de l’implémentation de la palette.\nToutefois, la programmation purement procédurale n’est pas sans intérêt dans les langages proches du matériel (on les appelle “de bas niveau”). Elle est par exemple utilisée dans le langage C. Le véritable langage des machines est en effet en lui-même procédural ; un processeur est essentiellement un composant électronique qui manipule des états de manière séquentielle. La programmation procédurale pour autant pas restreinte aux langages de bas-niveau ; Python notamment est un peu fourre-tout, mais reste relativement procédural.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-orientée-objet-poo",
    "href": "index.html#la-programmation-orientée-objet-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation orientée objet (POO)",
    "text": "La programmation orientée objet (POO)\nLa programmation orientée objet a émergé du besoin de faire apparaître une syntaxe disciplinée et plus proche d’une perception humaine. Pour ce faire, on s’inspire du monde réel : il n’y a pas besoin de connaitre le fonctionnement électronique d’une télécommande pour appuyer sur ses boutons. Il n’est pas attendu non plus que l’utilisateur d’une télévision aille bidouiller ses circuits imprimés pour s’en servir. Dans un langage objet, l’exemple précédent pourrait s’écrire :\n\npalette.ajouter(bleu)\npalette.ajouter(jaune)\npalette.mélanger()\nmur.peindre(palette.get_couleur())\n\nOn voit que palette, une instance d’objets de classe palette, possède a minima trois méthodes (ajouter, mélanger, et get_couleur). Puisqu’on s’est astreints à ne jamais accéder aux états internes de la palette, on a découplé le programme de peinture de celui des palettes. On n’a plus besoin de savoir comment est structurée intérieurement une palette (on ne sélectionne plus son troisième élément). La différence est de taille : la personne qui s’occupe de la maintenance des palettes peut maintenant les changer comme elle veut sans risquer de causer une erreur dans le programme de peinture (par exemple un mur jaune fluo à poids mauves). La seule chose qui doit être respectée, c’est le comportement des différentes méthodes.\n\n\n\n\n\n\nNote\n\n\n\nJava et C++ sont des langages objet populaires.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-fonctionnelle",
    "href": "index.html#la-programmation-fonctionnelle",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation fonctionnelle",
    "text": "La programmation fonctionnelle\nLà où la POO s’inspire des objets dans le monde réel, la programmation fonctionnelle s’inspire du monde des mathématiques. L’idée fondamentale de la programmation fonctionnelle est de ne plus manipuler d’états ; on n’utilise que ce qu’on appelle des “fonctions pures”. Celles-ci se comportent comme une calculatrice sans mémoire. Elles font un calcul purement combinatoire ; elles sont prévues pour retourner toujours le même résultat à partir des mêmes entrées.\n\nmur = mur_peint(couleur = mélanger(jaune, bleu))\n\nLa syntaxe fonctionnelle étant proche d’une écriture mathématique, elle convient aux langages de haut niveau prévus pour le calcul scientifique, comme R. Pendant longtemps (jusqu’aux années 2010), ce paradigme a été considéré comme assez académique et réservé aux profs de facs. Depuis les années 2010, cependant, le paradigme fonctionnel a rencontré un très net regain de popularité et est sorti des universités. Ses principaux intérêts sont :\n\nla grande facilité de déboggage et de test (une entrée doit toujours retourner la même sortie)\nla beauté/maintenabilité du code\nla forte parallélisabilité des calculs : les résultats ne dépendant que de leurs entrées, il est potentiellement possible de calculer plusieurs choses en même temps si l’on dispose de plusieurs CPU. C’est notamment cet aspect qui permet par exemple au package arrow d’être extrêmement rapide ; les calculs sont faits de manière possiblement concourrante plutôt que consécutive.\n\n\n\n\n\n\n\nNote\n\n\n\nOutre R, Haskell, Scala et Lisp sont des langages fonctionnels.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "href": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO",
    "text": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO\nR est très majoritairement un langage fonctionnel. Dans la mesure où aucun langage n’est entièrement soluble dans un paradigme, il présente également quelques petits traits de programmation objet tordus pour correspondre au coeur d’un langage fonctionnel. Le principal système de programmation objet en R, S3 (qui n’a rien à voir avec le protocole de stockage même s’il s’appelle similairement), adapte les principes de la POO dans le contexte de la programmation fonctionnelle.\nUn autre aspect particulier de R est qu’il est vectoriel. Si je fais :\n\n\n\n\n\n\nLa vectorisation est tout-à-fait implicite. Dans un langage procédural non-vectorisé, j’aurais plutôt écrit :\n\n\n\n\n\n\nCette dernière écriture est équivalente mais n’est pas très pratique pour écrire des statistiques….\n\n\n\n\n\n\nNote\n\n\n\nL’opérateur pipe %&gt;% repose sur les axiomes de la programmation fonctionnelle. Il suppose en effet que chaque sortie de fonction ne dépend que des entrées. Il permet de profiter à la fois de la simplicité d’une écriture de type “recette de cuisine” et des avantages de la programmation fonctionnelle.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#quizz",
    "href": "index.html#quizz",
    "title": "Introduction : les paradigmes de programmation",
    "section": "Quizz",
    "text": "Quizz\n\nQuestion 1\n\nDans un langage fonctionnel idéal :\n\n\n\n\n ✗On n’utilise que des procédures (des fonctions sans valeur de retour).\n\n\n ✓On n’utilise que des fonctions dites pures, c’est-à-dire des fonctions purement combinatoires.\n\n\n ✗On n’utilise que des fonctions, pures, ou non.\n\n\n ✗Différentes étapes successives qu’on appelle fonctions. On les applique sur des objets qu’elles modifient progressivement.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 2\n\nQuel est le rapport entretenu entre R et la Programmation Orientée Objet ?\n\n\n\n\n ✗R est un archétype de langage de POO.\n\n\n ✗On ne peut pas du tout faire de POO en R.\n\n\n ✗Objection votre honneur !\n\n\n ✓R est surtout un langage fonctionnel, mais il présente quelques aspects de POO et de programmation procédurale.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 3\n\nUn langage de bas niveau est un langage caractérisé par sa simplicité.\n\n\n\n\n ✓Non, c’est un langage proche du langage machine, donc souvent assez complexe et verbieux.\n\n\n ✗Exactement ! C’est un langage prévu pour être facile d’appréhension, d’où de “bas niveau”.\n\n\n ✗Non, un langage de bas-niveau est un langage est un langage qui est calculé dans la partie basse du chipset de la carte mère (le southbridge), tandis que les langages de haut niveau sont déterminés par sa partie haute (le northbridge).\n\n\n ✗Non, un langage de bas-niveau est un langage stromosogomique de capacitance inférimitésimale.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 4\n\nAnalysons ce pseudo-code :\n\nclasseur_ods = nouveau_classeur_ods()\nonglet = nouvel_onglet(donnee = “En voilà de la donnée”)\nclasseur_ods.ajouter_onglet(onglet)\nclasseur_ods.enregistrer(“/home/tintin/mon_classeur.ods”)\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✓Langage objet\n\n\n ✗Langage fonctionnel\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 5\n\nAnalysons ce pseudo-code :\n\na = [‘b’, ‘o’, ‘n’, ‘j’, ‘o’, ‘u’, ‘r’, ’ ’]\ni = 1\nwhile a[i] != ’ ’ {\n  print(a[i])\n  print(a[i])\n}\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✓Langage procédural\n\n\n ✗Langage objet\n\n\n ✗Langage fonctionnel\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 6\n\nAnalysons ce pseudo-code :\n\nracine_carrée(multiplier_par([entiers de 1 à 10], 3))\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✗Langage objet\n\n\n ✓Un langage fonctionnel ! Et vectoriel en plus ! C’est presque R !\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 7\n\nOn a vu qu’un langage objet permet notamment d’éviter les dépendances à l’implémentation.\nOn préfère écrire :\n\nmur.peindre(palette.get_couleur())\n\nQue :\n\npeindre_mur(mur, palette[3])\n\nQuel intérêt cela présente ?\n\n\n\n\n ✗Aucun, c’est purement esthétique.\n\n\n ✓Cela permet à un collègue d’être libre de modifier le fonctionnement interne de la palette sans faire bugger le programme de peinture.\n\n\n ✗Compter jusqu’à 3 est difficile car un ordinateur repose sur des nombres binaires. On préfère donc enlever le 3.\n\n\n ✗On a vraiment envie que le programme de peinture dépende du programme de la palette. Il faut que les gens travaillent en équipe et donc qu’ils soient chacun au courant de tout ce qu’il se passe dans l’intégralité du projet.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 8\n\nCombien de méthodes différentes de la classe discman ce pseudo-code utilise-t-il ?\n\ndiscman.brancher_ecouteurs(ecouteurs)\ndiscman.inserer_cd(never_mind_the_bollocks_here_s_the_sex_pistols)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\ndiscman.inserer_cd(peace_sells_but_who_s_buying)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\n\n\n\n\n\n ✗1\n\n\n ✗2\n\n\n ✗3\n\n\n ✓4\n\n\n ✗5\n\n\n ✗6\n\n\n ✗7\n\n\nEffacer la réponse",
    "crumbs": [
      "Introduction"
    ]
  }
]